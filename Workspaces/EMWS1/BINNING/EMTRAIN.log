MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 19, 2018" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "23:48:10" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                November 19, 2018
Time:                23:48:10
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2VN5YKK "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2VN5YKK new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 19, 2018" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "23:48:10" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                jmmorr01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70080761";
MPRINT(EM_DIAGRAM):   put "Platform:            X64_8PRO";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M3P062415";
MPRINT(EM_DIAGRAM):   put "EM Version:          14.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "November 19, 2018" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "23:48:10" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                jmmorr01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
103119     proc freq data=EMWS1.BINNING_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.BINNING_VariableSet noprint;
103120     table ROLE*LEVEL/out=WORK.BINNINGMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.BINNINGMETA;
103121     run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 13 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.BINNINGMETA has 6 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.07 seconds
      cpu time            0.01 seconds
      

103122     proc print data=WORK.BINNINGMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.BINNINGMETA label noobs;
103123     var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
103124     label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency Count";
103125     title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
103126     title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
103127     run;

NOTE: There were 6 observations read from the data set WORK.BINNINGMETA.
NOTE: The PROCEDURE PRINT printed page 39.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

103128     title10;
MPRINT(EM_DIAGRAM):   title10;
103129     %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'Project_4';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'Project 4';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
103481     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
103482     * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
103483     * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
103484     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

103485     %let EMEXCEPTIONSTRING=;
103486     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
103487     * TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   * TRAIN: BINNING;
103488     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
103489     %let EM_ACTION = TRAIN;
103490     %let syscc = 0;
103491     %macro main;
103492     
103493       filename temp catalog 'sashelp.emmdfy.binning_macros.source';
103494       %include temp;
103495       filename temp;
103496     
103497       %setProperties;
103498     
103499       %if %upcase(&EM_ACTION) = CREATE %then %do;
103500         filename temp catalog 'sashelp.emmdfy.binning_create.source';
103501         %include temp;
103502         filename temp;
103503     
103504         %create;
103505       %end;
103506     
103507        %else
103508        %if %upcase(&EM_ACTION) = TRAIN %then %do;
103509     
103510            filename temp catalog 'sashelp.emmdfy.binning_train.source';
103511            %include temp;
103512            filename temp;
103513            %train;
103514        %end;
103515     
103516       %else
103517       %if %upcase(&EM_ACTION) = SCORE %then %do;
103518         filename temp catalog 'sashelp.emmdfy.binning_score.source';
103519         %include temp;
103520         filename temp;
103521     
103522         %score;
103523     
103524       %end;
103525     
103526       %else
103527       %if %upcase(&EM_ACTION) = REPORT %then %do;
103528     
103529            filename temp catalog 'sashelp.emmdfy.binning_report.source';
103530            %include temp;
103531            filename temp;
103532     
103533            %report;
103534        %end;
103535     
103536        %doendm:
103537     %mend main;
103538     
103539     %main;
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_macros.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_MACROS.SOURCE.
103541    +%macro SetProperties;
103543    +     /* IGN options */
103544    +     %em_checkmacro(name=EM_PROPERTY_APPLYLEVELRULE, value=N, global=Y);
103545    +     %em_checkmacro(name=EM_PROPERTY_BINMETHOD,  value=QUANTILE, global=Y);
103546    +     %em_checkmacro(name=EM_PROPERTY_NUMBINS,    value=4, global=Y);
103548    +     %em_checkmacro(name=EM_PROPERTY_MISSINGASLEVEL, value=Y, global=Y);
103549    +     %em_checkmacro(name=EM_PROPERTY_PRECISION,    value=2, global=Y);
103550    +     %em_checkmacro(name=EM_PROPERTY_CREATEGROUPING, value=N, global=Y);
103551    +     %em_checkmacro(name=EM_PROPERTY_CREATEMETHOD, value=OVERWRITE, global=Y);
103552    +     %em_checkmacro(name=EM_PROPERTY_IMPORTGROUPING, value=N, global=Y);
103553    +     %em_checkmacro(name=EM_PROPERTY_IMPORTDATA, value=, global=Y);
103554    +     %em_checkmacro(name=EM_PROPERTY_FREEZE, value=N, global=Y);
103555    +     %em_checkmacro(name=EM_PROPERTY_VARSELMETHOD, value=GINI, global=Y);
103556    +     %em_checkmacro(name=EM_PROPERTY_GINICUTOFF,   value=20.0, global=Y);
103557    +     %em_checkmacro(name=EM_PROPERTY_GRPMSMNT,     value=ORDINAL, global=Y);
103558    +     %em_checkmacro(name=EM_PROPERTY_MAXVAR,       value=10, global=Y);
103559    +     %em_checkmacro(name=EM_PROPERTY_CLASSGROUPRARE, value=Y, global=Y);
103560    +     %em_checkmacro(name=EM_PROPERTY_GROUPCUTOFF,    value=0.5, global=Y);
103561    +     %em_checkmacro(name=EM_PROPERTY_GROUPMISSING,   value=N, global=Y);
103563    +     %em_checkmacro(name=EM_PROPERTY_INTTARGETMETHOD, value=CUTMEAN, global=Y);
103564    +     %em_checkmacro(name=EM_PROPERTY_USERCUTVALUE, value=0.2, global=Y);
103565    +     %em_checkmacro(name=EM_PROPERTY_RejectIntTarget, value=N, global=Y);
103568    +%mend SetProperties;
103569    +%macro appendfiles(fileref1, fileref2);
103570    +     data _null_;
103571    +       length c $256;
103572    +       fid1=fopen("&fileref1",'A');
103573    +       fid2=fopen("&fileref2",'I');
103574    +       cval = finfo(fid2,'lrecl');
103575    +       put cval= fid1= fid2=;
103576    +       if (fid2 > 0) then
103577    +         do while(fread(fid2)=0);
103578    +           rc = fget(fid2,c,256);
103579    +           _msg_=sysmsg();
103580    +           /* put rc= c= _msg_=; */
103581    +           rc = fput(fid1,strip(c));
103582    +           rc = fwrite(fid1);
103583    +         end;
103584    +         _msg_=sysmsg();
103585    +         put _msg_=;
103586    +       rc = fclose(fid1);
103587    +       rc = fclose(fid2);
103588    +     run;
103589    +%mend appendfiles;
103591    +%macro buildOptScoreCode;
103593    +    %em_register(key=BINCODE, type=FOLDER);
103595    +    filename x catalog 'sashelp.emutil.em_deldir.source';
103596    +    %inc x;
103597    +    filename x;
103598    +    %delDir(folder=%nrbquote(&em_user_bincode));
103600    +    data _null_; length rc $200;
103601    +       rc = dcreate('BINCODE', "&EM_NODEDIR");
103602    +    run;
103604    +    %if ^%sysfunc(exist(class_nosv)) %then %goto doendu;
103606    +    %let dsid = %sysfunc(open(class_nosv));
103607    +    %let nameNum    = %sysfunc(varnum(&dsid, DISPLAY_VAR));
103608    +    %let grpnameNum = %sysfunc(varnum(&dsid, _grp_variable_));
103610    +    %let oldname=;
103611    +    %do %while(^%sysfunc(fetch(&dsid)));
103612    +        %let name    = %sysfunc(getvarc(&dsid, &nameNum));
103613    +        %let grpname = %sysfunc(getvarc(&dsid, &grpnameNum));
103615    +        %if &name ne &oldname %then %do;
103616    +             filename _F1 "&em_user_bincode&em_dsep.&grpname..sas" MOD;
103617    +             data _null_;
103618    +                length string $200 flag endflag 8;
103619    +                retain string flag endflag;
103620    +                set class_nosv end=eof;
103621    +                where DISPLAY_VAR ="&name";
103622    +                by _variable_ _group_;
103623    +                file _F1;
103624    +                index = kindex(_variable_, "BIN_");
103625    +                if index gt 0 then do;
103626    +                   if first._variable_ then do;
103627    +                      put ' ';
103628    +                      put "&EM_CODEBAR;";
103629    +                      string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
103630    +                      put string;
103631    +                      put "&EM_CODEBAR;";
103633    +                      if origLabel ne "" then do;
103634    +                            string = 'LABEL '!!strip(_grp_variable_)!!' = ';
103635    +                            put string;
103636    +                            string = tranwrd(origLabel,"'","''");
103637    +                            string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
103638    +                            put string;
103639    +                      end;
103640    +                      else do;
103641    +                             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
103642    +                             put string;
103643    +                      end;
103645    +                      put ' ';
103647    +                      string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
103648    +                      put string;
103649    +                      string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
103650    +                      put string;
103651    +                      put "end;";
103652    +                      string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
103653    +                      put string;
103654    +                   end;
103655    +                   if first._group_ then do;
103656    +                      flag = 0;
103657    +                      endflag = 1;
103658    +                      if ^first._variable_ then do;
103659    +                         put "else";
103660    +                      end;
103661    +                      if LB ne . then do;
103662    +                         string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
103663    +                      end;
103664    +                      else do;
103665    +                         flag = 1;
103666    +                         string = "if";
103667    +                      end;
103668    +                   end;
103669    +                   if last._Group_ then do;
103670    +                      if UB ne . then do;
103671    +                        if flag ne 1 then do;
103672    +                          string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
103673    +                        end;
103674    +                        else do;
103675    +                          string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
103676    +                        end;
103677    +                      end;
103678    +                      else do;
103679    +                         if flag=1 then do;
103680    +                            string = strip(DISPLAY_VAR) ;
103681    +                            string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
103682    +                            endflag=0;
103683    +                            string="";
103684    +                         end;
103685    +                         else do;
103686    +                            string = strip(string)!!" then do;";
103687    +                         end;
103688    +                      end;
103689    +                      put string;
103690    +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
103691    +                      put string;
103692    +                      if endflag eq 1 then do;
103693    +                        put "end;";
103694    +                      end;
103695    +                   end;
103696    +                   if last._variable_ then do;
103697    +                     string = "end;";
103698    +                     put string;
103699    +                   end;
103701    +                end;
103702    +                else do;
103703    +                   _split_value_ = tranwrd(_split_value_,"'","''");
103704    +                   if first._group_ then do;
103705    +                      flag=0;
103706    +                      if ^first._variable_ then
103707    +                         put 'else';
103708    +                      else do;
103709    +                         put ' ';
103710    +                         put "&EM_CODEBAR;";
103711    +                         string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
103712    +                         put string;
103713    +                         put "&EM_CODEBAR;";
103715    +                         if origLabel ne "" then do;
103716    +                               string = 'LABEL '!!strip(_grp_variable_)!!' = ';
103717    +                               put string;
103718    +                               string = tranwrd(origLabel,"'","''");
103719    +                               string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
103720    +                               put string;
103721    +                         end;
103722    +                         else do;
103723    +                               string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
103724    +                               put string;
103725    +                         end;
103727    +                         put ' ';
103729    +                         if format ne '' then do;
103730    +                            if first._variable_ then do;
103731    +                               string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
103732    +                               put string;
103733    +                               string = '%dmnormip(_UFormat);';
103734    +                               put string;
103736    +                               string ="if MISSING(_UFORMAT) then do;";
103737    +                               put string;
103738    +                               string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
103739    +                               put string;
103740    +                               put "end;";
103742    +                               string="else if NOT MISSING(_UFORMAT) then do;";
103743    +                               put string;
103745    +                            end;
103746    +                         end;
103747    +                         else do;
103748    +                            if type = 'N' then do;
103749    +                              string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
103750    +                              put string;
103751    +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
103752    +                              put string;
103753    +                              put "end;";
103755    +                              string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
103756    +                              put string;
103757    +                            end;
103758    +                            else if type='C' then do;
103759    +                              string = "_UFormat = "||strip(DISPLAY_VAR)||";";
103760    +                              put string;
103761    +                              string = '%dmnormip(_UFormat);';
103762    +                              put string;
103764    +                              string ="if MISSING(_UFORMAT) then do;";
103765    +                              put string;
103766    +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
103767    +                              put string;
103768    +                              put "end;";
103770    +                              string="else if NOT MISSING(_UFORMAT) then do;";
103771    +                              put string;
103772    +                              string = '%dmnormip(_UFormat);';
103773    +                              put string;
103774    +                           end;
103775    +                         end;
103776    +                      end;
103777    +                      if format ne '' OR type='C' then do;
103778    +                        string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
103779    +                      end;
103780    +                      else do;
103781    +                        string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
103782    +                      end;
103783    +                   end;
103784    +                   else do;
103785    +                      if flag ne 1 then do;
103786    +                       if format ne '' OR type='C' then do;
103787    +                         tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
103788    +                       end;
103789    +                       else do;
103790    +                         tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
103791    +                       end;
103792    +                         length = length(tempstring);
103794    +                         if length < 195 then do;
103795    +                            string = tempstring;
103796    +                         end;
103797    +                         else do;
103799    +                            string = strip(string);
103800    +                            put string;
103801    +                            string = ") then do;";
103802    +                            put string;
103804    +                            string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
103805    +                            put string;
103806    +                            put "end;";
103808    +                            put 'else';
103809    +                            if format ne '' OR type='C' then do;
103810    +                              string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
103811    +                            end;
103812    +                            else do;
103813    +                              string = "if "!!strip(DISPLAY_VAR)!!" eq ("!!strip(_split_value_);
103814    +                            end;
103815    +                         end;
103816    +                      end;
103817    +                   end;
103819    +                   if last._group_ then do;
103820    +                      string = strip(string);
103821    +                      put string;
103823    +                      string = ") then do;";
103824    +                      put string;
103826    +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
103827    +                      put string;
103828    +                      put "end;";
103829    +                   end;
103831    +                   if last._variable_ then do;
103832    +                     put "else do;";
103834    +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
103835    +                     put string;
103837    +                     put "end;";
103838    +                     put "end;";
103839    +                   end;
103840    +                end;
103841    +             run;
103843    +             %let oldname = &name;
103844    +        %end;
103845    +    %end;
103846    +    %let dsid = %sysfunc(close(&dsid));
103848    +    filename _F1 "&em_user_bincode&em_dsep._ALL_.sas";
103849    +    data _null_;
103850    +       file _F1;
103851    +       put "length _UFormat $200;";
103852    +       put "drop _UFormat;";
103853    +       put "_UFormat='';";
103854    +    run;
103855    +    filename _F1;
103857    +   %em_register(key=EMSCOREVAR, type=DATA);
103858    +   %let scorevarDs = %scan(&em_user_emscorevar, 2, .);
103859    +   proc datasets lib=&em_lib nolist;
103860    +      delete &scorevarDs;
103861    +   run;
103862    +   quit;
103864    +   %let filrf=mydir;
103865    +   %let rc=%sysfunc(filename(filrf,&em_user_bincode));
103866    +   %let did=%sysfunc(dopen(&filrf));
103868    +   %if &did %then %do;  %PUT  did= &did;
103869    +       %let memcount=%sysfunc(dnum(&did));
103870    +       %if &memcount > 0 %then %do;
103871    +           data &em_user_emscorevar;
103872    +              length Name $32 formula $70 file $200;
103873    +              keep NAME Formula file;
103874    +              formula  = '';
103875    +           %if %sysfunc(fileexist(&em_user_bincode&em_dsep._ALL_.sas)) %then %do;
103876    +               name=''; file="BINCODE&em_dsep._ALL_.sas";
103877    +               output;
103878    +           %end;
103879    +           %do i=1 %to &memcount;
103880    +               %let name =%nrbquote(%sysfunc(dread(&did,&i)));
103881    +               %let newvar = %scan(&name, 1, .);
103882    +               %if "&newvar" ne "_ALL_" %then %do;
103883    +                   name = "&newvar"; file="BINCODE&em_dsep&name";
103884    +                   output;
103885    +               %end;
103886    +           %end;
103888    +           run;
103889    +       %end;
103890    +       %let did = %sysfunc(dclose(&did));
103891    +  %end;
103893    +   %doendu:
103894    +%mend buildOptScoreCode;
103897    +%macro buildScoreCode(flowCode, publishCode);
103900    +  filename x "&flowCode";
103902    +  proc sort data=&EM_USER_SPLITVALS; by display_var _split_Value_; run;
103903    +  proc sort data=&EM_USER_BINMAPPINGS; by display_var bin; run;
103904    +  proc sort data=&EM_USER_coarse out=tempcoarse; by display_var _group_; run;
103906    +  data temp;
103907    +    merge &EM_USER_SPLITVALS &EM_USER_BINMAPPINGS(rename=(BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
103908    +    by display_var _Split_value_;
103909    +     if upcase(_Split_value_) ne 'MISSING';
103910    +   run;
103912    +   data temp_missing;
103913    +     merge &EM_USER_SPLITVALS(rename=(_GROUP_=MISSGRP)) &EM_USER_BINMAPPINGS(rename=(
103914    +          BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
103915    +     by display_var _Split_value_;
103916    +     if upcase(_Split_value_) eq 'MISSING';
103917    +     keep _variable_ display_var missgrp;
103918    +   run;
103920    +   proc sort data=temp_missing; by display_var missgrp; run;
103922    +   data temp_missing;
103923    +     merge temp_missing(in=_a) tempcoarse(rename=(_GROUP_=MISSGRP));
103924    +     by display_var missgrp;
103925    +     if ^_a then delete;
103926    +     keep _variable_ display_var missgrp ;
103927    +   run;
103929    +   data temp;
103930    +     merge temp temp_missing;
103931    +     by display_var;
103932    +     if display_Var eq '' then delete;
103933    +    run;
103935    +    /* pull in wtev values */
103936    +    proc sort data=&EM_USER_varmappings out=tempmappings; by _variable_; run;
103937    +    proc sort data=&EM_IMPORT_DATA_CMETA out=tempcmeta; by NAME; run;
103938    +    proc sort data=temp;  by display_var _group_; run;
103940    +   data temp;
103941    +      merge temp tempcoarse(keep=display_var _group_  role) ;
103942    +      by display_var _group_;
103943    +    run;
103945    +    data temp;
103946    +      merge temp tempmappings(rename=(_variable_ = display_var)) tempcmeta(keep=NAME FORMAT TYPE LABEL rename=(NAME=display_var LABEL=origLabel));
103947    +      by display_var;
103949    +      if _group_ = . then delete;
103950    +      if _variable_ = '' then delete;
103951    +    run;
103953    +    proc sort data=temp out=class;
103954    +       by _variable_ _group_ LB;
103955    +    run;
103957    +    data _null_;
103958    +      file X;
103960    +      put "length _UFormat $200;";
103961    +      put "drop _UFormat;";
103962    +      put "_UFormat='';";
103963    +    run;
103965    +    data class_nosv;
103966    +      set class;
103967    +      if upcase(role)="INPUT";
103968    +    run;
103970    +    data _null_;
103971    +       file X MOD;
103972    +       length string $200 flag endflag 8;
103973    +       retain string flag endflag;
103974    +       set class_nosv end=eof;
103975    +       by _variable_ _group_;
103977    +       index = kindex(_variable_, "BIN_");
103978    +       if index gt 0 then do;
103980    +         if first._variable_ then do;
103981    +            put ' ';
103982    +            put "&EM_CODEBAR;";
103983    +            string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
103984    +            put string;
103985    +            put "&EM_CODEBAR;";
103988    +            if origLabel ne "" then do;
103989    +              string = 'LABEL '!!strip(_grp_variable_)!!' = ';
103990    +              put string;
103991    +              string = tranwrd(origLabel,"'","''");
103992    +              string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
103993    +              put string;
103994    +            end;
103995    +            else do;
103996    +             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
103997    +             put string;
103998    +            end;
104000    +            put ' ';
104002    +            string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
104003    +            put string;
104004    +            string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
104005    +            put string;
104006    +            put "end;";
104007    +            string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
104008    +            put string;
104009    +          end;
104010    +           if first._group_ then do;
104011    +              flag = 0;
104012    +              endflag = 1;
104013    +              if ^first._variable_ then do;
104014    +                put "else";
104015    +              end;
104016    +              if LB ne . then do;
104017    +                 string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
104018    +              end;
104019    +              else do;
104020    +                 flag = 1;
104021    +                 string = "if";
104022    +              end;
104024    +           end;
104025    +           if last._Group_ then do;
104026    +              if UB ne . then do;
104027    +                if flag ne 1 then do;
104028    +                  string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
104029    +                end;
104030    +                else do;
104031    +                  string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
104032    +                end;
104033    +              end;
104034    +              else do;
104035    +                 if flag=1 then do;
104036    +                   string = strip(DISPLAY_VAR) ;
104037    +                   string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
104038    +                   endflag = 0;
104039    +                   string="";
104040    +                 end;
104041    +                 else do;
104042    +                   string = strip(string)!!" then do;";
104043    +                 end;
104044    +              end;
104045    +              put string;
104047    +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
104048    +              put string;
104049    +              if endflag eq 1 then do;
104050    +                put "end;";
104051    +              end;
104052    +           end;
104053    +           if last._variable_ then do;
104054    +             string = "end;";
104055    +             put string;
104056    +           end;
104057    +       end;
104058    +       else do;
104059    +           _split_value_ = tranwrd(_split_value_,"'","''");
104060    +           if first._group_ then do;
104061    +              flag=0;
104062    +              if ^first._variable_ then
104063    +                 put 'else';
104064    +              else do;
104065    +                 put ' ';
104066    +                 put "&EM_CODEBAR;";
104067    +                 string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
104068    +                 put string;
104069    +                 put "&EM_CODEBAR;";
104071    +                 if origLabel ne "" then do;
104072    +                   string = 'LABEL '!!strip(_grp_variable_)!!' = ';
104073    +                   put string;
104074    +                   string = tranwrd(origLabel,"'","''");
104075    +                   string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
104076    +                   put string;
104077    +                 end;
104078    +                 else do;
104079    +                   string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
104080    +                   put string;
104081    +                 end;
104083    +                 put ' ';
104085    +                if format ne '' then do;
104086    +                  if first._variable_ then do;
104087    +                    string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
104088    +                    put string;
104089    +                    string = '%dmnormip(_UFormat);';
104090    +                    put string;
104092    +                     string ="if MISSING(_UFORMAT) then do;";
104093    +                     put string;
104094    +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
104095    +                     put string;
104096    +                     put "end;";
104098    +                     string="else if NOT MISSING(_UFORMAT) then do;";
104099    +                     put string;
104101    +                  end;
104102    +                end;
104103    +                else do;
104104    +                     if type = 'N' then do;
104105    +                       string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
104106    +                       put string;
104107    +                       string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
104108    +                       put string;
104109    +                       put "end;";
104111    +                       string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
104112    +                       put string;
104114    +                     end;
104115    +                     else if type='C' then do;
104116    +                        string = "_UFormat = "||strip(DISPLAY_VAR)||";";
104117    +                        put string;
104118    +                        string = '%dmnormip(_UFormat);';
104119    +                        put string;
104121    +                        string ="if MISSING(_UFORMAT) then do;";
104122    +                        put string;
104123    +                        string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
104124    +                        put string;
104125    +                        put "end;";
104127    +                        string="else if NOT MISSING(_UFORMAT) then do;";
104128    +                        put string;
104129    +                        string = '%dmnormip(_UFormat);';
104130    +                        put string;
104131    +                    end;
104132    +                end;
104133    +              end;
104134    +              if format ne '' OR type='C' then do;
104135    +                string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
104136    +              end;
104137    +              else do;
104138    +                string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
104139    +              end;
104140    +           end;
104141    +           else do;
104142    +              if flag ne 1 then do;
104143    +                if format ne '' OR type='C' then do;
104144    +                  tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
104145    +                end;
104146    +                else do;
104147    +                  tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
104148    +                end;
104149    +                length = klength(tempstring);
104151    +                if length < 195 then do;
104152    +                   string = tempstring;
104153    +                end;
104154    +                else do;
104156    +                   string = strip(string);
104157    +                   put string;
104158    +                   string = ") then do;";
104159    +                   put string;
104161    +                   string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
104162    +                   put string;
104163    +                   put "end;";
104165    +                 /*  string = strip(string)||",'...';"; */
104167    +                   put 'else';
104168    +                   if format ne '' OR type='C' then do;
104169    +                     string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
104170    +                   end;
104171    +                   else do;
104172    +                     string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
104173    +                   end;
104176    +                end;
104177    +              end;
104178    +           end;
104180    +           if last._group_ then do;
104181    +              string = strip(string);
104182    +              put string;
104183    +              string = ") then do;";
104184    +              put string;
104186    +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
104187    +              put string;
104188    +              put "end;";
104189    +           end;
104191    +           if last._variable_ then do;
104192    +             put "else do;";
104194    +             string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
104195    +             put string;
104197    +             put "end;";
104198    +             put "end;";
104199    +           end;
104200    +         *end;
104201    +       end;
104202    +    run;
104204    +    /* generate PublishCode the same as flowscorecode */
104205    +    filename Y "&publishCode";
104207    +    /* if publishCode already exists, wipe it out first */
104208    +    %if %sysfunc(fexist(Y)) eq 1 %then %do;
104209    +      %let rc = %sysfunc(fdelete(Y));
104210    +    %end;
104212    +    %appendfiles(Y, X);
104214    +    %if %EM_BINARY_TARGET= %then %do;
104215    +      %if %symexist(EM_NUM_INTERVAL_TARGET)=0 %then %do;
104216    +         %em_varMacro(name=EM_INTERVAL_TARGET, metadata=&EM_DATA_variableSet, where=%nrbquote(ROLE="TARGET" and LEVEL="INTERVAL" and (USE="Y" or USE="D")), nummacro=em_num_interval_Target);
104217    +      %end;
104218    +      %let ibn_inttarget=%EM_INTERVAL_TARGET;
104219    +      %let ibn_inttarget_orig = &ibn_inttarget;
104221    +      %if %symexist(IGNBinTarget)=0 %then %do;
104222    +         %global ignbintarget ignfreqvar;
104223    +         filename temp catalog 'sashelp.emutil.em_getvarname.source';
104224    +         %include temp;
104225    +         filename temp;
104226    +         %getVarName(&EM_IMPORT_DATA, BIN_%substr(&ibn_inttarget,1,%sysfunc(min(%length(&ibn_inttarget),28))), IGNBinTarget);
104228    +         %if &EM_PROPERTY_INTTARGETMETHOD = DUPFREQ %then %do;
104229    +            %getVarName(&EM_IMPORT_DATA, _FREQ_, ignfreqvar);
104230    +         %end;
104231    +      %end;
104232    +      %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
104233    +         proc sql noprint;
104234    +            %if %EM_FREQ ne %then %do;
104235    +               select sum(&ibn_inttarget * %EM_FREQ) / sum(%EM_FREQ)
104236    +            %end;
104237    +            %else %do;
104238    +               select mean(&ibn_inttarget)
104239    +            %end;
104240    +            into :ignbincut trimmed from &EM_IMPORT_DATA;
104241    +         quit;
104242    +      %end;
104244    +      %let dsid=%sysfunc(open(&EM_IMPORT_DATA,i));
104245    +      %if &dsid %then %do;
104246    +         %let tarlabel=%trim(%sysfunc(varlabel(&dsid,%sysfunc(varnum(&dsid,&ibn_inttarget)))));
104247    +         %let rc=%sysfunc(close(&dsid));
104248    +      %end;
104249    +      %if %length(&tarlabel)=0 %then %let tarlabel = &ibn_inttarget;
104251    +      data _null_;
104252    +         file x mod;
104253    +         put ' ';
104255    +         %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
104256    +             put "&EM_CODEBAR;";
104257    +             %let note = Mean Cutoff Binary Transformation for Target;
104258    +             put "* &note;";
104259    +             put "&EM_CODEBAR;";
104260    +         %end;
104261    +         %else %if &EM_PROPERTY_INTTARGETMETHOD = CUTUSER %then %do;
104262    +             put "&EM_CODEBAR;";
104263    +             %let note = User-Specified Cutoff Binary Transformation for Target;
104264    +             put "* &note;";
104265    +             put "&EM_CODEBAR;";
104266    +             %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
104267    +         %end;
104268    +         put "if &ibn_inttarget = . then &IGNBinTarget = .;";
104269    +         put "else do;";
104270    +         put "   if &ibn_inttarget > &ignbincut then &IGNBinTarget=1;";
104271    +         put "   else &IGNBinTarget=0;";
104272    +         put "end;";
104274    +         put "label &IGNBinTarget = 'Binary: %nrbquote(%substr(&tarlabel,1,192))';";
104275    +      run;
104277    +      filename deltaref "&EM_FILE_CDELTA_TRAIN";
104279    +      %if &EM_PROPERTY_RejectIntTarget = Y %then %do;
104281    +         data _null_;
104282    +            file deltaref;
104283    +            put "if name='&ibn_inttarget_orig' then role='REJECTED';";
104284    +            put "if name='&IGNBinTarget' then do;";
104285    +            put "   role='TARGET';";
104286    +            put "   level='BINARY';";
104287    +            put "end;";
104288    +         run;
104290    +      %end;
104291    +      %else %do;
104293    +         data _null_;
104294    +            file deltaref;
104295    +            put "if name='&ibn_inttarget_orig' then role='TARGET';";
104296    +            put "if name='&IGNBinTarget' then do;";
104297    +            put "   role='REJECTED';";
104298    +            put "   level='BINARY';";
104299    +            put "end;";
104300    +         run;
104301    +      %end;
104303    +      filename deltaref;
104305    +   %end;
104307    +    filename X;
104308    +    filename Y;
104310    +    %buildOptScoreCode;
104312    +    proc datasets library=work nolist;
104313    +      delete class class_nosv temp temp_missing tempmappings tempcmeta;
104314    +    run;
104315    +    quit;
104317    +%mend buildScoreCode;
104319    +%macro buildMetaCode(DeltaCodeFile=);
104321    +   /* set variable roles based on New Role column in the Results table */
104322    +   data _null_;
104323    +      file &DeltaCodeFile %if %length(%EM_BINARY_TARGET)=0 %then mod;;
104324    +      %let dsid = %sysfunc(open(&EM_USER_RESULTSTABLE));
104325    +      %if &dsid %then %do;
104326    +        %let obs = %sysfunc(fetch(&dsid));
104327    +        %let vnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
104328    +        %let rnum = %sysfunc(VARNUM(&dsid, _new_role_));
104329    +        %let ornum = %sysfunc(VARNUM(&dsid, _role_));
104331    +        %do %while(&obs=0);
104332    +          %let inputname = %sysfunc(getvarc(&dsid, &vnum));
104333    +          %let role      = %upcase(%sysfunc(getvarc(&dsid, &rnum)));
104334    +          %let oldrole   = %upcase(%sysfunc(getvarc(&dsid, &ornum)));
104336    +          /* retrieve grp and woe names from varmappings dataset */
104337    +          %let choice = _VARIABLE_ = "&inputname";
104338    +          %let cdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
104339    +          %let cobs = %sysfunc(fetchobs(&cdsid, 1));
104340    +          %let grpnum = %sysfunc(VARNUM(&cdsid, _GRP_VARIABLE_));
104341    +          %let grpname = %sysfunc(getvarc(&cdsid, &grpnum));
104342    +          %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
104344    +          put "if name = '&inputname' then role='REJECTED';";
104345    +          %if "&role" ne "DEFAULT" %then %do;
104346    +            put "if name = '&grpname' then role='&role';";
104347    +          %end;
104348    +          %else %do;
104349    +            put "if name = '&grpname' then role='&oldrole';";
104350    +          %end;
104351    +          put "if name = '&grpname' then level='&EM_PROPERTY_GRPMSMNT';";
104353    +          %let obs = %sysfunc(fetch(&dsid));
104354    +        %end;
104355    +      %end;
104356    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
104357    +   run;
104359    +   /* drop all vars in the splitvals dataset that aren't present in the varmappings dataset */
104360    +   data _null_;
104361    +      file &DeltaCodeFile MOD;
104363    +      %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
104364    +      %if &sdsid %then %do;
104365    +        %let sobs = %sysfunc(fetch(&sdsid));
104366    +        %do %while(&sobs=0);
104367    +          %let varnum = %sysfunc(VARNUM(&sdsid, _VARIABLE_));
104368    +          %let checkname = %sysfunc(getvarc(&sdsid, &varnum));
104369    +          %let dispvarnum = %sysfunc(VARNUM(&sdsid, DISPLAY_VAR));
104370    +          %let displayvar = %sysfunc(getvarc(&sdsid, &dispvarnum));
104372    +          %let checkgrp = GRP_&checkname;
104373    +          %let lenname = %length(&checkgrp);
104374    +          %if %eval(&lenname-32) > 0 %then %do;
104375    +            %let checkgrp = %substr(&checkgrp, 1, 32);
104376    +          %end;
104378    +          %let choice = _VARIABLE_ ="&checkname";
104379    +          %let vdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
104381    +          /* if var not found in varmappings, delete variables; */
104382    +          /* this could happen when freeze=Y and vars in the frozen dataset aren't in the incoming training data */
104383    +          %if &vdsid eq 0 %then %do;
104384    +            put 'if name="&displayvar" then delete;';
104385    +            %let dispgrp = GRP_&displayvar;
104386    +            put 'if name="&dispgrp" then delete;';
104387    +          %end;
104389    +          %if &vdsid > 0 %then %let vdsid = %sysfunc(close(&vdsid));
104390    +          %let sobs = %sysfunc(fetch(&sdsid));
104391    +        %end;
104392    +      %end;
104393    +      %if &sdsid > 0 %then %let sdsid= %sysfunc(close(&sdsid));
104394    +   run;
104396    +%mend buildMetaCode;
104398    +%macro EM_GENERATE_RESULTSTABLE(coarse, resultstable, varmappings);
104400    +   proc sort data=&coarse out=sortedcoarse nodupkey;
104401    +     by display_var;
104402    +   run;
104403    +   proc sort data=&varmappings nodupkey;
104404    +     by _variable_;
104405    +   run;
104406    +   %if %sysfunc(exist(&resultstable, data)) %then %do;
104407    +     proc sort data=&resultstable; by display_var; run;
104409    +     /* check that _new_role exists - did not exist in earlier releases */
104410    +     %let rds=%sysfunc(open(&resultstable));
104411    +     %let _newrolenum = %sysfunc(VARNUM(&rds, _new_role_));
104412    +     %let rds=%sysfunc(close(&rds));
104413    +   %end;
104415    +   data &resultstable (Keep = display_var _gini_  _role_ _new_role_ procLevel);
104416    +     merge sortedcoarse(in=_a) &varmappings(rename=(_Variable_ = DISPLAY_VAR))
104417    +     %if %sysfunc(exist(&resultstable, data)) %then %do;
104418    +        &resultstable (keep = display_var %if &_newrolenum %then _new_role_; )
104419    +     %end;
104420    +     ;
104421    +     by display_var;
104422    +     length _role_ _new_role_ $10;
104423    +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
104424    +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_ginistatistic_vlabel , NOQUOTE))"
104425    +           _role_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_calcrole_vlabel, NOQUOTE))"
104426    +           _new_role_ = "%sysfunc(sasmsg(sashelp.dmine, meta_NEWROLE_vlabel, NOQUOTE))"
104427    +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))"
104428    +           ;
104430    +           %if &EM_PROPERTY_VARSELMETHOD eq GINI %then %do;
104431    +             if _gini_ < &EM_PROPERTY_GINICUTOFF then
104432    +                _role_ = "Rejected";
104433    +             else _role_ = "Input";
104434    +           %end;
104435    +           %else %do;
104436    +             _role_ = "Input";
104437    +           %end;
104438    +           if _new_role_ eq "" then _new_role_="Default";
104439    +      if ^_a then do;
104440    +        _gini_ = 0;
104441    +        _role_ = 'Rejected';
104442    +        if _new_role_ eq "" then _new_role_="Default";
104443    +      end;
104444    +   run;
104445    +   proc sort data=&EM_DATA_VARIABLESET out=outlabel(keep=NAME LABEL LEVEL rename=(NAME=display_var LABEL=_label_));
104446    +     by NAME;
104447    +   run;
104448    +   data outlabel;
104449    +     set outlabel;
104450    +     if _label_ = '' then _label_ = _variable_;
104451    +   run;
104452    +   data &resultstable;
104453    +     merge &resultstable(in=_a_) outlabel;
104454    +     by display_Var;
104455    +     if _a_ then output;
104456    +   run;
104457    +   proc datasets library=work nolist;
104458    +     delete sortedcoarse outlabel;
104459    +   run;
104460    +   quit;
104461    +   proc sort data=&resultstable nodupkey;
104462    +      by DESCENDING
104463    +        _gini_ display_Var;
104464    +   run;
104465    +   data &resultstable;
104466    +     set &resultstable;
104468    +     label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))"
104469    +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))";
104470    +     giniOrder = _N_;
104471    +     _gini_ = round(_GINI_, .001);
104472    +     drop _variable_;
104473    +   run;
104475    +   proc print data=&resultstable label;
104476    +   run;
104478    +   /* merge role, infovalOrder or giniOrder back into Coarse table as well */
104479    +   data &coarse;
104480    +     set &coarse;
104481    +     length role $10;
104482    +     %let dsid = %sysfunc(open(&resultstable));
104483    +     %if &dsid %then %do;
104484    +       %let disnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
104485    +       %let rolenum = %sysfunc(VARNUM(&dsid, _ROLE_));
104486    +       %let orderNum = %sysfunc(VARNUM(&dsid, giniOrder));
104488    +       %let obs = %sysfunc(fetch(&dsid));
104489    +       %do %while(&obs=0);
104490    +          %let displayvar = %sysfunc(getvarc(&dsid, &disnum));
104491    +          %let role       = %sysfunc(getvarc(&dsid, &rolenum));
104492    +          %let order = %sysfunc(getvarn(&dsid, &ordernum));
104494    +                                                                                               if DISPLAY_VAR = "&displayVar" then do;
104495    +            label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))";
104496    +            giniOrder = &order;
104497    +            role = "&role";
104498    +          end;
104500    +          %let obs = %sysfunc(fetch(&dsid));
104501    +       %end;
104502    +     %end;
104503    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
104504    +   run;
104507    +%mend EM_GENERATE_RESULTSTABLE;
104509    +%macro EM_GENERATE_EXPORTGROUP(exportGrouping, createMethod);
104511    +    /* instantiate the zchar macro to be used in adding bin definition */
104512    +    filename _temp catalog 'sashelp.emmacs.zchar.source';
104513    +    %inc _temp;
104514    +    filename _temp;
104516    +    proc sort data=&EM_USER_FINEDETAILDATA out=sortedfine;
104517    +      by _variable_ binFlag _group_ LB;
104518    +    run;
104520    +    data tempExport;
104521    +      set sortedFine;
104522    +      by _variable_ binFlag _group_;
104523    +      length _split_value_ $200;
104525    +      /* for all binned variables, need to modify the split value to original cutoff as well as change level to interval */
104526    +      if binFlag = 0 then do;
104527    +        index = kindex(_variable_, "BIN_");
104528    +        if index gt 0 then do;
104529    +          _LEVEL_ = "INTERVAL";
104530    +        end;
104531    +        _Split_value_ = _split_value_;
104532    +        output;
104533    +      end;
104534    +      else do;
104535    +         * if last._group_ then do;
104536    +          index = kindex(_variable_, "BIN_");
104537    +          if index gt 0 then do;
104538    +            _LEVEL_ = "INTERVAL";
104539    +          end;
104540    +          _Split_value_ = %zchar(UB);
104541    +          output;
104542    +         * end;
104543    +      end;
104545    +      rename display_Var = _variable_;
104546    +      keep display_var _level_ _group_ _split_value_ binFlag;
104547    +    run;
104549    +    %if &CREATEMETHOD eq OVERWRITE %then %do;
104550    +       data &EXPORTGROUPING;
104551    +         set tempexport;
104552    +       run;
104553    +    %end;
104554    +    %else %do;
104555    +       /* determine if EXPORTGROUPING already exists */
104556    +       %if %sysfunc(exist(&EXPORTGROUPING, DATA)) %then %do;
104557    +         data &EXPORTGROUPING;
104558    +            set &EXPORTGROUPING tempexport;
104559    +         run;
104560    +       %end;
104561    +       %else %do;
104562    +         data &EXPORTGROUPING;
104563    +            set tempexport;
104564    +         run;
104565    +       %end;
104566    +    %end;
104568    +    proc datasets lib=work nolist;
104569    +      delete sortedFine tempexport;
104570    +    run;
104571    +    quit;
104573    +%mend EM_GENERATE_EXPORTGROUP;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(MAIN):  ;
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_TRAIN.SOURCE.
104579    +%macro train;
104581    +   /* include training macros */
104582    +   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
104583    +   %include trtemp;
104584    +   filename trtemp;
104586    +   /* trick IGN into thinking it is a model node to build decmeta; further down, set %EM_MODEL ASSESS=N
104587    +   %let EM_TOOLTYPE = MODEL; */
104589    +   %if &EM_IMPORT_DATA eq %then %do;
104590    +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN, 1;
104591    +       %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, error_nodeTrainRawData_note , NOQUOTE));
104592    +       %put &em_codebar;
104593    +       %put &errmsg;
104594    +       %put &em_codebar;
104595    +       %goto doendm;
104596    +   %end;
104598    +   %if  &EM_NUM_TARGET ne 1 %then %do;
104599    +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
104600    +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR  , NOQUOTE));
104601    +        %put &em_codebar;
104602    +        %put &errmsg;
104603    +        %put &em_codebar;
104604    +        %goto doendm;
104605    +   %end;
104607    +  %if  &EM_NUM_BINARY_TARGET ne 1 and &EM_NUM_INTERVAL_TARGET ne 1 %then %do;
104608    +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
104609    +        %put &em_codebar;
104610    +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR, NOQUOTE));
104611    +        %put &errormsg;
104612    +        %put &em_codebar;
104613    +        %goto doendm;
104614    +   %end;
104616    +   /* Initialize property macro variables */
104617    +   %SetProperties;
104618    +   %EM_GETNAME(key=NEWTRAIN, type=DATA);
104620    +   /* check actual num of target levels */
104621    +   %let target_level = %EM_TARGET_LEVEL;
104622    +   %let target_var = %EM_TARGET;
104623    +   %if (&target_Level eq BINARY) %then %do;
104624    +      /* retrieve target information */
104625    +      /* does decmeta exist?  If not, retrieve target information elsewhere */
104626    +      %global target_event;
104627    +      %let target_event=;
104629    +     /* need to check that order is the same in both for cases where they can be out of synch */
104630    +     %if "&EM_DEC_DECMETA" ne "" %then %do;
104631    +         /* retrieve target information */
104632    +         %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='TARGET'))));
104634    +         %let vn_event =%sysfunc(varnum(&dsid, EVENT));
104635    +         %let vn_target_type = %sysfunc(varnum(&dsid, TYPE));
104636    +         %let vn_target_format = %sysfunc(varnum(&dsid, FORMAT));
104637    +         %let vn_target_order = %sysfunc(varnum(&dsid, ORDER));
104639    +         %do %while(^ %sysfunc(fetch(&dsid)));
104640    +            %let temp = %nrbquote(%sysfunc(getvarc(&dsid, &vn_event)));
104641    +            %let Target_Event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
104642    +            %let Target_Type =  %sysfunc(getvarc(&dsid, &vn_target_type));
104643    +            %let Target_Format = %sysfunc(getvarc(&dsid, &vn_target_format));
104644    +            %let Target_Order_DM = %sysfunc(getvarc(&dsid, &vn_target_order));
104645    +         %end;
104646    +         %let dsid = %sysfunc(close(&dsid));
104647    +     %end;
104648    +     %else %let Target_Order_DM=;
104650    +     /* retrieve type and format from variableset */
104651    +     %let eventorder = DESC;
104652    +     data temp;
104653    +       set &EM_DATA_VARIABLESET;
104654    +       where NAME ="%EM_BINARY_TARGET";
104655    +     run;
104657    +     %let dsid = %sysfunc(open(work.temp));
104658    +     %if &dsid %then %do;
104659    +       %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
104660    +       %let formatnum = %sysfunc(VARNUM(&dsid, FORMAT));
104661    +       %let ordernum  = %sysfunc(VARNUM(&dsid, ORDER));
104662    +       %let obs = %sysfunc(fetchobs(&dsid, 1));
104663    +       %let Target_type = %sysfunc(getvarc(&dsid, &typenum));
104664    +       %let Target_Format = %sysfunc(getvarc(&dsid, &formatnum));
104665    +       %let Target_Order  = %sysfunc(getvarc(&dsid, &ordernum));
104666    +     %end;
104667    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
104669    +     %if "&EM_DEC_DECMETA" eq "" or ("&Target_Order" ne "&Target_Order_DM") %then %do;
104671    +       %if &TARGET_ORDER  = ASC %then %let eventorder = ASC;
104672    +          %else
104673    +       %if &TARGET_ORDER  = DESC %then %let eventorder = DESC;
104674    +          %else
104675    +       %if &TARGET_ORDER  = FMTASC %then %let eventorder = ASCFMT;
104676    +          %else
104677    +       %if &TARGET_ORDER  = FMTDESC %then %let eventorder = DESFMT;
104679    +        /* retrieve target_event and Target_nonEvent values */
104680    +        proc dmdb data=&EM_IMPORT_DATA(where=(^missing(%EM_BINARY_TARGET))) classout=EVENTOUT;
104681    +          target %EM_BINARY_TARGET;
104682    +          class  %EM_BINARY_TARGET(&eventorder);
104683    +        run;
104685    +        data _null_;
104686    +          dsid = open("EVENTOUT");
104687    +          if dsid>0 then do;
104688    +          levelnum = VARNUM(dsid, "LEVEL");
104689    +          if levelnum then do;
104690    +            if ^fetch(dsid) then
104691    +              call symput('TARGET_EVENT',   strip(getvarc(dsid, levelnum)));
104693    +            if ^fetch(dsid) then
104694    +              call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
104695    +          end;
104696    +          dsid=close(dsid);
104697    +          end;
104698    +        run;
104699    +        proc datasets library=work nolist;
104700    +           delete eventout;
104701    +        run;
104702    +        quit;
104703    +      %end;
104704    +      %else %do;
104705    +          %let dsid=%sysfunc(open(&EM_DEC_DECDATA(where=(%EM_BINARY_TARGET ne "&Target_Event"))));
104706    +          %let obs = %sysfunc(fetchobs(&dsid, 1));
104707    +           %let vn_nonevent = %sysfunc(varnum(&dsid, %EM_BINARY_TARGET));
104708    +           %let Target_NonEvent= %sysfunc(getvarc(&dsid, &vn_nonevent));
104709    +         %let dsid = %sysfunc(close(&dsid));
104710    +      %end;
104712    +      %global ignbintarget;
104713    +      %let ignbintarget = %EM_BINARY_TARGET;
104715    +      data &EM_USER_NEWTRAIN;
104716    +        set &EM_IMPORT_DATA;
104717    +      run;
104718    +   %end;
104719    +   %else %do; /* preprocessing for interval target */
104720    +      %if &EM_PROPERTY_INTTARGETMETHOD=CUTUSER %then %do;
104721    +         proc dmdb data=&EM_IMPORT_DATA varout=minmax;
104722    +            var &target_var;
104723    +         run;
104725    +         data _null_;
104726    +            set minmax;
104727    +            call symput('tarmax',strip(max));
104728    +            call symput('tarmin',strip(min));
104729    +         run;
104731    +         /* cutoff can equal tarmin but not tarmax */
104732    +         %if %sysevalf(&EM_PROPERTY_USERCUTVALUE >= &tarmax) or %sysevalf(&EM_PROPERTY_USERCUTVALUE < &tarmin) %then %do;
104733    +            %let EMEXCEPTIONSTRING = exception.server.IGN.CUTOFFOUTOFRANGE,&tarmin,&tarmax;
104734    +            %put &em_codebar;
104735    +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, cutoffoutofrange_error, NOQUOTE, &tarmin, &tarmax));
104736    +            %put &errormsg;
104737    +            %put &em_codebar;
104738    +            %goto doendm;
104739    +         %end;
104740    +      %end;
104742    +      %global ignbintarget;
104743    +      %getVarName(&EM_IMPORT_DATA, BIN_%substr(%EM_INTERVAL_TARGET,1,%sysfunc(min(%length(%EM_INTERVAL_TARGET),28))), IGNBinTarget);
104745    +      %EM_IBN_IntTargetTrans(%EM_INTERVAL_TARGET,&EM_PROPERTY_INTTARGETMETHOD,newLevels=igntbinlevs);
104746    +      %if &igntbinlevs ne 2 %then %do;
104747    +         %let EMEXCEPTIONSTRING = exception.server.IGN.NONBINTARGETTRANS;
104748    +         %put &em_codebar;
104749    +         %let errormsg = %sysfunc(sasmsg(sashelp.dmine, nonbintargettrans_error, NOQUOTE));
104750    +         %put &errormsg;
104751    +         %put &em_codebar;
104752    +         %goto doendm;
104753    +      %end;
104755    +      %let Target_Event = 1;
104756    +      %let Target_NonEvent = 0;
104757    +      %let Target_Type = BINARY;
104758    +      %let Target_Format = ;
104760    +   %end;
104762    +   /* data sets */
104763    +   %EM_GETNAME(key=BINDATA,        type=DATA);
104764    +   %EM_GETNAME(key=SPLITVALS,      type=DATA);
104765    +   %EM_GETNAME(key=VARMAPPINGS,    type=DATA);
104766    +   %EM_GETNAME(key=BINMAPPINGS,    type=DATA);
104767    +   %EM_GETNAME(key=COARSE,          type=DATA);
104768    +   %EM_GETNAME(key=FINEDETAILDATA, type=DATA);
104769    +   %EM_GETNAME(key=RESULTSTABLE,   type=DATA);
104771    +   /* files */
104772    +   %EM_GETNAME(key=BINNINGCODE, type=FILE, extension=sas);
104773    +   %EM_GETNAME(key=GROUPMAPPINGSCORECODE, type=FILE, extension=sas);
104775    +   /* if freeze eq Y and no finedetaildata exists, throw an exception */
104776    +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
104777    +     %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) ne 1 %then %do;
104778    +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOFINEDETAIL;
104779    +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, nofinedetail_error , NOQUOTE));
104781    +        %put &em_codebar;
104782    +        %put &errmsg;
104783    +        %put &em_codebar;
104784    +        %goto doendm;
104785    +     %end;
104786    +   %end;
104788    +   %global useImport;
104789    +   %let useImport = 0;
104791    +   %EM_GETNAME(key=IMPORTSUBSET, type=DATA);
104793    +   %if %sysfunc(exist(&EM_USER_IMPORTSUBSET, DATA)) %then %do;
104794    +     proc datasets library=&EM_LIB nolist;
104795    +       delete &EM_NODEID._IMPORTSUBSET;
104796    +     run;
104797    +     quit;
104798    +   %end;
104800    +   /* if importGrouping=Y, verify that data and all vars exist and are of the correct type */
104801    +   %if &EM_PROPERTY_IMPORTGROUPING eq Y %then %do;
104803    +     /* if import eq Y and no importtable exists, throw an exception */
104804    +     %if %sysfunc(exist(&EM_PROPERTY_IMPORTDATA, DATA)) ne 1 %then %do;
104805    +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOIMPORT;
104806    +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, noimport_error , NOQUOTE));
104808    +        %put &em_codebar;
104809    +        %put &errmsg;
104810    +        %put &em_codebar;
104811    +        %goto doendm;
104812    +     %end;
104814    +      %let dsid = %sysfunc(open(&EM_PROPERTY_IMPORTDATA));
104815    +      %if &dsid %then %do;
104816    +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
104817    +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
104818    +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
104819    +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
104821    +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
104822    +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
104823    +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
104824    +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
104825    +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
104826    +         %end;
104827    +      %end;
104828    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
104830    +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
104831    +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
104833    +        /* generate subset of data that contains those vars also found in training data and add display_var information */
104834    +        proc sort data=&EM_PROPERTY_IMPORTDATA out=tempimport;
104835    +           by _VARIABLE_ ;
104836    +        run;
104838    +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
104839    +          by NAME;
104840    +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
104841    +        run;
104843    +        data &EM_USER_IMPORTSUBSET;
104844    +          merge tempimport(in=_a) tempvarset(in=_b);
104845    +          length display_Var $32;
104846    +          by _VARIABLE_;
104847    +          display_var = _Variable_;
104848    +          if _a and _b then output;
104849    +        run;
104851    +        proc datasets library=work nolist;
104852    +          delete tempimport tempvarset;
104853    +        run;
104854    +        quit;
104856    +        %end;
104857    +      %end;
104858    +   %end;
104860    +   /* set useImport flag if there are obs in the importSubset dataset */
104861    +   %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET));
104862    +   %if &dsid %then %do;
104863    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
104864    +     %if &nobs gt 0 %then %let useimport = 1;
104865    +   %end;
104866    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
104868    +   %global useFreeze;
104869    +   %let useFreeze = 0;
104871    +   /* if Freeze=Y, verify that data and all vars exist and are of the correct type */
104872    +   %EM_GETNAME(key=FREEZESUBSET, type=DATA);
104874    +   %if %sysfunc(exist(&EM_USER_FREEZESUBSET, DATA)) %then %do;
104875    +     proc datasets library=&EM_LIB nolist;
104876    +       delete &EM_NODEID._FREEZESUBSET;
104877    +     run;
104878    +     quit;
104879    +   %end;
104881    +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
104883    +      /* create freezesubset data to contain information on pre-binned data and raw values */
104884    +      %EM_GENERATE_EXPORTGROUP(&EM_USER_FREEZESUBSET, OVERWRITE);
104886    +      %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
104887    +      %if &dsid %then %do;
104888    +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
104889    +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
104890    +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
104891    +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
104893    +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
104894    +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
104895    +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
104896    +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
104897    +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
104898    +         %end;
104899    +      %end;
104900    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
104902    +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
104903    +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
104905    +        /* generate subset of data that contains those vars also found in training data */
104906    +        proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze;
104907    +           by _VARIABLE_ ;
104908    +        run;
104910    +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
104911    +          by NAME;
104912    +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
104913    +        run;
104915    +        data &EM_USER_FREEZESUBSET;
104916    +          merge tempfreeze(in=_a) tempvarset(in=_b);
104917    +          length display_Var $32;
104918    +          by _VARIABLE_;
104919    +          display_var = _Variable_;
104920    +          if _a and _b then output;
104921    +        run;
104923    +        proc datasets library=work nolist;
104924    +          delete tempfreeze tempvarset;
104925    +        run;
104926    +        quit;
104927    +        %end;
104928    +      %end;
104929    +   %end;
104931    +   /* set useFreeze flag if there are obs in the freezeSubset dataset */
104932    +   %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
104933    +   %if &dsid %then %do;
104934    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
104935    +     %if &nobs gt 0 %then %let useFreeze = 1;
104936    +   %end;
104937    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
104939    +   /* if finedetail already exists, delete prior to re-run */
104940    +   %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) %then %do;
104941    +     proc datasets library=&EM_LIB nolist;
104942    +       delete &EM_NODEID._FINEDETAILDATA;
104943    +     run;
104944    +     quit;
104945    +   %end;
104947    +   data tempvarnames;
104948    +     set &EM_DATA_VARIABLESET;
104949    +     where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
104950    +     keep NAME LEVEL LABEL;
104951    +   run;
104953    +   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
104954    +     names NAME;
104955    +     prefix WOE_ GRP_ ;
104956    +   run;
104958    +   proc sort data=tempmapping; by name; run;
104959    +   proc sort data=tempvarnames; by name; run;
104960    +   data tempmapping;
104961    +     merge tempmapping tempvarnames;
104962    +     by NAME;
104963    +     rename LEVEL=procLevel;
104964    +   run;
104966    +   /* generate initial columns of mapping table by setting grpflag=0 */
104967    +   %EM_GENERATE_MAPPING_TABLE;
104969    +   proc datasets library=work nolist;
104970    +     delete tempImport tempScore;
104971    +   run;
104972    +   quit;
104974    +   /* delete splitvals dataset if this existed prior to run */
104975    +   %let nvars=0;
104976    +   %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
104977    +   %if &sdsid > 0 %then %do;
104978    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
104979    +   %end;
104980    +   %if &sdsid > 0 %then  %let sdsid=%sysfunc(close(&sdsid));
104982    +   %if &nvars > 0 %then %do;
104983    +      proc datasets library=&EM_LIB nolist;
104984    +        delete &EM_NODEID._SPLITVALS;
104985    +      run;
104986    +      quit;
104987    +   %end;
104989    +   %global classvars qclassvars;
104990    +   %let classvars=;
104991    +   %let qclassvars=;
104993    +   /* generate the intervalvars and classvars macros */
104994    +   %EM_PRE_BINNING(&EM_USER_NEWTRAIN);
104996    +   /* update varmappings with any changes to procLevel based on discretemid */
104997    +   data &EM_USER_VARMAPPINGS;
104998    +     set &EM_USER_VARMAPPINGS;
104999    +     /* procLevel column to indicate the level used by proc; this handles*/
105000    +     /* cases in which var is marked INTERVAL in metadat but treated as  */
105001    +     /* ordinal in prebinning because of # unique levels                 */
105002    +     %let dsid = %sysfunc(open(work._discretemid));
105003    +     %if &dsid %then %do;
105004    +       %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
105005    +       %let obs = %sysfunc(fetch(&dsid));
105006    +       %do %while(&obs=0);
105007    +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
105008    +          if _variable_ = "&varname" then procLevel = "ORDINAL";
105009    +          %let obs = %sysfunc(fetch(&dsid));
105010    +       %end;
105011    +     %end;
105012    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105013    +     label procLevel =  "%sysfunc(sasmsg(sashelp.dmine, rpt_proclevel_vlabel , NOQUOTE))";
105014    +   run;
105016    +   /* generate Grp_xxx variables for interval inputs */
105017    +   %if &EM_PROPERTY_BINMETHOD eq QUANTILE %then %do;
105018    +     %EM_QUANTILE_BINNING(&EM_USER_NEWTRAIN, WORK.PCTILE, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
105020    +   %end;
105021    +   %else %do;
105022    +     %EM_EQUAL_SPACED_BINNING(&EM_USER_NEWTRAIN, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
105023    +   %end;
105025    +   /* generate GRP_XXX variables for nominal inputs */
105026    +   %EM_CLASSVARS_GROUP(&EM_PROPERTY_CLASSGROUPRARE);
105028    +   /* generate GRP_XXX variables for ordinal inputs */
105029    +   %EM_ORDVARS_GROUP;
105031    +   proc print data=&EM_USER_VARMAPPINGS label;
105032    +     var _VARIABLE_ _GRP_VARIABLE_ ;
105033    +   run;
105035    +   /* add _proc_var_ to varmappings data to know names of processed variables; could be original input, could be bin_xxx */
105036    +   proc sort data=&EM_USER_SPLITVALS out=tempsplitvals nodupkey;
105037    +     by _VARIABLE_;
105038    +   run;
105040    +   data &EM_USER_VARMAPPINGS;
105041    +     set &EM_USER_VARMAPPINGS;
105042    +     length _proc_var_ $32;
105043    +     %let dsid = %sysfunc(open(work.tempsplitvals));
105044    +     %if &dsid %then %do;
105045    +        %let obs = %sysfunc(fetch(&dsid));
105046    +        %do %while(&obs=0);
105047    +          %let dispnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
105048    +          %let dispvar = %sysfunc(getvarc(&dsid, &dispnum));
105049    +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
105050    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
105052    +          if upcase(_VARIABLE_) = %upcase("&dispvar") then _proc_var_ = "&var";
105053    +          %let obs = %sysfunc(fetch(&dsid));
105054    +        %end;
105055    +     %end;
105056    +     if missing(_proc_var_) then _proc_var_=_variable_;
105057    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105058    +   run;
105060    +   proc datasets library=work nolist;
105061    +     delete sortedbin tempsplitvals;
105062    +   run;
105063    +   quit;
105065    +   /* calculate Fine Detail statistics for each input */
105066    +   %EM_FINE_DETAIL(&EM_USER_BINDATA, &EM_USER_VARMAPPINGS, &EM_USER_FINEDETAILDATA, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS);
105068    +   /* apply grouping and create grouped dataset */
105069    +   %EM_CREATE_GROUPING(&EM_USER_BINDATA, &EM_USER_FINEDETAILDATA, &EM_USER_COARSE);
105071    +   /* generate _label_ values in the COARSE dataset from the Scored data */
105072    +   filename Y "&EM_USER_GROUPMAPPINGSCORECODE";
105073    +   %EM_GENERATE_LABELVALUES(Y, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS, &EM_USER_COARSE);
105074    +   filename Y;
105076    +   /* set EM_MODEL ASSESS=N to prevent assessment reports from being generated */
105077    +   %EM_MODEL(Target= &ignbintarget, ASSESS=N);
105079    +   /* generate reports */
105080    +   %EM_REPORT(key=COARSE, viewtype=DATA, block=MODEL, description=EVENTRATESTAT, autodisplay=N, spk=N);
105083    +   %doendm:
105084    +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
NOTE: %INCLUDE (level 1) file TRTEMP is file SASHELP.EMMDFY.BINNING_TRAINMACROS.SOURCE.
105086    +%macro EM_GENERATE_MAPPING_TABLE;
105088    +  %EM_GETNAME(key=VARMAPPINGS, type=DATA);
105089    +  data &EM_USER_VARMAPPINGS(keep=_variable_  _grp_variable_ procLevel label);
105090    +   length _variable_  _grp_variable_  $32 procLevel $8;
105091    +   set tempmapping;
105092    +   label _variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_inputvar_vlabel , NOQUOTE))"
105093    +         _grp_variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_grpvar_vlabel , NOQUOTE))";
105095    +         _variable_ = NAME;
105096    +         _grp_variable_ = GRP;
105097    + run;
105099    +%mend EM_GENERATE_MAPPING_TABLE;
105101    +%macro EM_PRE_BINNING(input);
105102    +    /* Determine which of our variables are interval  */
105104    +    data tempvariableset;
105105    +      set &EM_DATA_VARIABLESET;
105106    +      where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
105107    +    run;
105109    +    /* add all interval vars to the intervalvar macro
105110    +    %let dsid = %sysfunc(open(work.tempvariableset));
105111    +    %if &dsid %then %do;
105112    +       %let varnum = %sysfunc(VARNUM(&dsid, NAME));
105113    +       %let obs = %sysfunc(fetch(&dsid));
105114    +       %do %while(&obs=0);
105115    +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
105116    +          %let intervalvars = &intervalvars &varname;
105117    +          %let obs = %sysfunc(fetch(&dsid));
105118    +       %end;
105119    +    %end;
105120    +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105121    + */
105123    +   %em_varmacro(name=intervalvars, metadata=tempvariableset, key=NAME, nummacro=num_intvars);
105125    +    /* Determine which variables marked as interval are true interval distributions; */
105126    +    /* intmid contains variables that are actually interval and should be binned; */
105127    +    /* discretemid contains variables that are actually discrete and should NOT be binned */
105128    +    %if %intervalvars ne %then %do;
105129    +      %let _maxlevel = %eval(&EM_PROPERTY_NUMBINS + 1);
105130    +      proc dmdb data=&input classout=_CLASSOUT maxlevel=&_maxlevel;
105131    +        class %intervalvars;
105132    +      run;
105133    +      proc freq data=_CLASSOUT order=DATA noprint;
105134    +         table NAME / OUT= _COUNT(where=(COUNT<&_maxlevel));
105135    +      run;
105137    +      %let _INTBINS=;
105138    +      data _null_;
105139    +        set _COUNT;
105140    +        call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
105141    +      run;
105143    +      proc sort data=_CLASSOUT;
105144    +        by NAME;
105145    +      run;
105146    +      proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
105147    +        var NRAW;
105148    +        by NAME;
105149    +      run;
105151    +      data _null_;
105152    +        dsid = open('_OUT');
105153    +        if dsid then do;
105154    +           call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
105155    +           csid = close(dsid);
105156    +        end;
105157    +      run;
105158    +      data _INTMID;
105159    +        set _OUT;
105160    +        keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
105161    +        %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
105162    +          if ^indexw("&_INTBINS", VARIABLE) then output;
105163    +        %end;
105164    +      run;
105166    +      %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
105167    +        data _DISCRETEMID;
105168    +          set _OUT;
105169    +          keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
105170    +          if indexw("&_INTBINS", VARIABLE) then output;
105171    +        run;
105172    +      %end;
105173    +      %else %do;
105174    +         %if %sysfunc(exist(_discretemid)) %then %do;
105175    +            proc delete data=_discretemid;
105176    +            run;
105177    +         %end;
105178    +      %end;
105180    +      /* add vars from the _DISCRETEMID dataset to the classvars macro
105181    +      %let dsid = %sysfunc(open(WORK._DISCRETEMID));
105182    +      %if &dsid %then %do;
105183    +        %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
105184    +        %let obs = %sysfunc(fetch(&dsid));
105186    +        %do %while(&obs=0);
105187    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
105188    +          %let classvars = &classvars &var;
105189    +          %let qclassvars = &qclassvars "&var";
105190    +          %let obs = %sysfunc(fetch(&dsid));
105191    +        %end;
105192    +      %end;
105193    +      %if &dsid  %then %let dsid = %sysfunc(close(&dsid));
105194    +*/
105195    +    %end;
105196    +    %else %do;
105197    +      %if %sysfunc(exist(_intmid)) %then %do;
105198    +         proc delete data=_intmid;
105199    +         run;
105200    +      %end;
105202    +      %if %sysfunc(exist(_discretemid)) %then %do;
105203    +         proc delete data=_discretemid;
105204    +         run;
105205    +      %end;
105206    +    %end;
105208    +    /* if import grouping then remove interval vars in import data from _INTMID */
105209    +    %if &useImport eq 1 %then %do;
105211    +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
105212    +        by _VARIABLE_;
105213    +      run;
105215    +      data &EM_USER_IMPORTSUBSET;
105216    +        length CODEVAR $32;
105217    +        set &EM_USER_IMPORTSUBSET;
105218    +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
105219    +      run;
105221    +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
105222    +        by _VARIABLE_;
105223    +      run;
105225    +      %let dsid = %sysfunc(open(work.tempsubset));
105226    +      %let nobs = 0;
105227    +      %if &dsid %then %do;
105228    +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
105229    +      %end;
105230    +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
105232    +      data tempsubset;
105233    +        set tempsubset;
105234    +        length  binVar suffix $32;
105235    +        array binnames{&nobs} $32 _temporary_;
105236    +        retain binVar binnames;
105237    +        by _VARIABLE_;
105239    +        binVar = 'BIN_'!!strip(CODEVAR);
105240    +        binVar = ksubstr(binVar, 1, 32);
105241    +        count = 1;
105243    +        do i=1 to _N_;
105244    +           do while(binvar eq binnames(i));
105245    +              suffix = strip(put(count,best.));
105246    +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
105247    +              count + 1;
105248    +           end;
105249    +        end;
105250    +        binnames(_N_)= binvar;
105251    +        output;
105252    +        drop suffix count i;
105253    +     run;
105255    +     data &EM_USER_IMPORTSUBSET;
105256    +       set &EM_USER_IMPORTSUBSET;
105257    +       length binVar $32;
105259    +        %let dsid = %sysfunc(open(work.tempsubset));
105260    +        %if &dsid %then %do;
105261    +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
105262    +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
105263    +          %let obs = %sysfunc(fetch(&dsid));
105265    +          %do %while(&obs=0);
105266    +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
105267    +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
105269    +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
105270    +            %let obs = %sysfunc(fetch(&dsid));
105271    +          %end;
105272    +        %end;
105273    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105274    +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
105275    +        if binVar ne "" then do;
105276    +          _LEVEL_ = "ORDINAL";
105277    +        end;
105279    +      run;
105281    +      %let idsidexists=0;
105282    +      %let idsid = %sysfunc(open(work._intmid));
105283    +      %if &idsid %then %do;
105284    +        %let idsidexists=1;
105285    +        %let idsid = %sysfunc(close(&idsid));
105286    +      %end;
105288    +      %if &idsidexists = 1 %then %do;
105289    +      data _INTMID;
105290    +        set _INTMID;
105292    +        %let dsid = %sysfunc(open(work.tempsubset));
105293    +        %if &dsid %then %do;
105294    +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
105295    +          %let obs = %sysfunc(fetch(&dsid));
105297    +          %do %while(&obs=0);
105298    +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
105299    +            if variable = "&codevar" then delete;
105300    +            %let obs = %sysfunc(fetch(&dsid));
105301    +          %end;
105302    +        %end;
105303    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105304    +      run;
105305    +      %end;
105307    +      proc datasets library=work nolist;
105308    +        delete tempsubset;
105309    +      run;
105310    +      quit;
105311    +    %end;
105313    +    /* if freeze then remove interval vars in import data from _INTMID */
105314    +    %if &useFreeze eq 1 %then %do;
105316    +      data &EM_USER_FREEZESUBSET;
105317    +        length CODEVAR $32;
105318    +        set &EM_USER_FREEZESUBSET;
105319    +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
105320    +      run;
105322    +      proc sort data=&EM_USER_FREEZESUBSET out=tempsubset nodupkey;
105323    +        by _VARIABLE_;
105324    +      run;
105326    +      %let dsid = %sysfunc(open(work.tempsubset));
105327    +      %let nobs = 0;
105328    +      %if &dsid %then %do;
105329    +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
105330    +      %end;
105331    +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
105333    +      data tempsubset;
105334    +        set tempsubset;
105335    +        length  binVar suffix $32;
105336    +        array binnames{&nobs} $32 _temporary_;
105337    +        retain binVar binnames;
105338    +        by _VARIABLE_;
105340    +        binVar = 'BIN_'!!strip(CODEVAR);
105341    +        binVar = ksubstr(binVar, 1, 32);
105342    +        count = 1;
105344    +        do i=1 to _N_;
105345    +           do while(binvar eq binnames(i));
105346    +              suffix = strip(put(count,best.));
105347    +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
105348    +              count + 1;
105349    +           end;
105350    +        end;
105351    +        binnames(_N_)= binvar;
105352    +        output;
105353    +        drop suffix count i;
105354    +     run;
105356    +     data &EM_USER_FREEZESUBSET;
105357    +       set &EM_USER_FREEZESUBSET;
105358    +       length binVar $32;
105360    +        %let dsid = %sysfunc(open(work.tempsubset));
105361    +        %if &dsid %then %do;
105362    +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
105363    +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
105364    +          %let obs = %sysfunc(fetch(&dsid));
105366    +          %do %while(&obs=0);
105367    +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
105368    +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
105370    +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
105371    +            %let obs = %sysfunc(fetch(&dsid));
105372    +          %end;
105373    +        %end;
105374    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105376    +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
105377    +        if binVar ne "" then do;
105378    +          _LEVEL_ = "ORDINAL";
105379    +        end;
105381    +      run;
105383    +      %let idsidexists= 0;
105384    +      %let idsid = %sysfunc(open(work._intmid));
105385    +      %if &idsid %then %do;
105386    +        %let idsidexists=1;
105387    +        %let idsid = %sysfunc(close(&idsid));
105388    +      %end;
105389    +      %if &idsidexists eq 1 %then %do;
105390    +      data _INTMID;
105391    +        set _INTMID;
105393    +        %let dsid = %sysfunc(open(work.tempsubset));
105394    +        %if &dsid %then %do;
105395    +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
105396    +          %let obs = %sysfunc(fetch(&dsid));
105398    +          %do %while(&obs=0);
105399    +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
105400    +            if variable = "&codevar" then delete;
105401    +            %let obs = %sysfunc(fetch(&dsid));
105402    +          %end;
105403    +        %end;
105404    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105405    +      run;
105406    +      %end;
105408    +      proc datasets library=work nolist;
105409    +        delete tempsubset;
105410    +      run;
105411    +      quit;
105413    +    %end;
105415    +%mend EM_PRE_BINNING;
105417    +%macro EM_IMPORT_BINNING(binningCode);
105420    +   data tempintimport;
105421    +     set &EM_USER_IMPORTSUBSET;
105422    +     if binflag = 1;
105423    +   run;
105425    +   %let idsid = %sysfunc(open(work.tempintimport));
105426    +   %if &idsid %then %do;
105427    +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
105428    +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
105429    +   %end;
105430    +   %else %do;
105431    +     %let nvars = 0;
105432    +     %let nobs = 0;
105433    +   %end;
105434    +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
105436    +   proc datasets library=work nolist;
105437    +     delete tempintimport;
105438    +   run;
105439    +   quit;
105441    +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
105443    +      filename X "&binningCode";
105444    +      data _null_;
105445    +        FILE X MOD;
105446    +        %let bin_variables=;
105447    +        %let quote_bin_variables = ;
105448    +        %let choice = binflag = 1;
105449    +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
105450    +        %if &dsid %then %do;
105451    +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
105452    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
105453    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
105454    +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingbins_note , NOQUOTE));
105456    +           put "&EM_CODEBAR;";
105457    +           put " &note; ";
105458    +           put "&EM_CODEBAR;";
105460    +           /* retrieve value for first obs */
105461    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
105462    +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
105463    +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
105465    +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
105466    +           %let i = 1;
105467    +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
105468    +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
105469    +           %end;
105470    +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
105471    +           put " ";
105472    +           put "if &oldname eq . then &binvalue = .;";
105474    +           /* cycle through special codes if they exist */
105475    +           %let index2 = %index(&oldname, SV_);
105476    +           %if &index2 gt 0 %then %do;
105477    +             %let choice = CODEVAR ="&oldname";
105478    +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
105479    +             %if &cdsid %then %do;
105480    +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
105481    +                %let cobs = %sysfunc(fetch(&cdsid));
105482    +                %do %while(&cobs=0);
105483    +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
105484    +                    put "else if &oldname eq &code then &binvalue = &code;";
105485    +                   %let cobs = %sysfunc(fetch(&cdsid));
105486    +                %end;
105487    +             %end;
105488    +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
105489    +           %end;
105490    +           put "else ";
105491    +           %if "&value" eq "." %then %do;
105492    +             put " &binvalue=&i;";
105493    +           %end;
105494    +           %else %do;
105495    +             put "  if &oldname < &value then &binvalue=&i;";
105496    +           %end;
105498    +           %let i= %eval(&i+1);
105500    +           %let obs = %sysfunc(fetch(&dsid));
105501    +           %do %while(&obs=0);
105502    +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
105503    +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
105504    +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
105506    +              %if "&oldname" ne "&namevalue" %then %do;
105508    +                /* if variable has been re-coded for special codes, must include these values as well */
105509    +                put;
105510    +                put "if &namevalue eq . then &binvalue = .;";
105512    +                %let i=1;
105513    +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
105514    +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
105515    +                %end;
105516    +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
105518    +                /* cycle through special codes if they exist */
105519    +                %let index2 = %index(&namevalue, SV_);
105520    +                %if &index2 gt 0 %then %do;
105521    +                  %let choice = CODEVAR ="&namevalue";
105522    +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
105523    +                  %if &cdsid %then %do;
105524    +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
105525    +                     %let cobs = %sysfunc(fetch(&cdsid));
105526    +                     %do %while(&cobs=0);
105527    +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
105528    +                       put "else if &namevalue eq &code then &binvalue = &code;";
105529    +                       %let cobs = %sysfunc(fetch(&cdsid));
105530    +                     %end;
105531    +                  %end;
105532    +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
105533    +                %end;
105534    +                put "else ";
105535    +                %if "&value" ne "." %then %do;
105536    +                  put "  if &namevalue < &value then &binvalue=&i;";
105537    +                %end;
105538    +                %else %do;
105539    +                  put " &binvalue=&i;";
105540    +                %end;
105542    +              %end;
105543    +              %else %do;
105544    +                put "else ";
105545    +                %if "&value" ne "." %then %do;
105546    +                  put "  if &namevalue < &value then &binvalue=&i;";
105547    +                %end;
105548    +                %else %do;
105549    +                  put "  &binvalue=&i;";
105550    +                %end;
105551    +              %end;
105552    +              %let i = %eval(&i + 1);
105553    +              %let obs = %sysfunc(fetch(&dsid));
105554    +              %let oldname = &namevalue;
105555    +              %let oldbinvalue = &binvalue;
105556    +           %end;
105557    +        %end;
105558    +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
105560    +      run;
105561    +      filename X;
105562    +      /* generate BINMAPPINGS dataset */
105563    +      data TEMPBINMAPPINGS;
105564    +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
105566    +        %let choice = binflag = 1;
105567    +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
105568    +        %if &dsid %then %do;
105569    +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
105570    +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
105571    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
105572    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
105573    +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
105575    +           /* retrieve information from first obs */
105576    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
105577    +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
105578    +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
105579    +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
105580    +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar,5));
105581    +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
105582    +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
105583    +           %let i = 1;
105585    +           NAME = "&OLDCODEVAR";
105586    +           BIN_NAME = "&OLDBINVAR";
105587    +           GRP_NAME = "&OLDGRPVAR";
105588    +           BIN = "&i";
105589    +           GRP = "&oldgrpvalue";
105590    +           LB = . ;
105591    +           UB = &oldvalue;
105592    +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
105593    +           DISPLAY_VAR = "&oldvar";
105594    +           output;
105596    +           %let i = 2;
105597    +           %let obs = %sysfunc(fetch(&dsid));
105598    +           %do %while(&obs=0);
105599    +             %let var = %sysfunc(getvarc(&dsid, &varnum));
105600    +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
105601    +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
105602    +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar,5));
105603    +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
105604    +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
105606    +             %if "&oldvar" ne "&var" %then %do;
105607    +              %let i = 1;
105608    +               %let oldvalue = .;
105609    +             %end;
105611    +             NAME = "&CODEVAR";
105612    +             BIN_NAME = "&BINVAR";
105613    +             GRP_NAME = "&GRPVAR";
105614    +             BIN = "&i";
105615    +             GRP = "&group";
105616    +             LB = &oldvalue ;
105617    +             UB = &value;
105618    +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
105619    +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
105620    +             %end;
105621    +             %else %do;
105622    +               %if "&oldvalue" eq "." %then %do;
105623    +                 EM_BIN_LABEL = "&var < &value" ;
105624    +               %end;
105625    +               %if "&value" eq "." %then %do;
105626    +                 EM_BIN_LABEL = "&oldvalue <= &var";
105627    +               %end;
105628    +             %end;
105629    +             DISPLAY_VAR = "&var";
105630    +             output;
105632    +             %let oldvar = &var;
105633    +             %let oldcodevar = &codevar;
105634    +             %let oldbinvar = &binvar;
105635    +             %let oldgrpvar = &grpvar;
105636    +             %let oldvalue   = &value;
105637    +             %let oldgrpvalue   = &group;
105638    +             %let i = %eval(&i + 1);
105639    +             %let obs = %sysfunc(fetch(&dsid));
105640    +           %end;
105641    +        %end;
105642    +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
105643    +      run;
105645    +      data &EM_USER_BINMAPPINGS;
105646    +        set &EM_USER_BINMAPPINGS tempBinMappings;
105647    +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
105648    +      run;
105650    +      /* update importsubset with bin values instead of raw values */
105651    +      data &EM_USER_IMPORTSUBSET;
105652    +        set &EM_USER_IMPORTSUBSET;
105654    +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
105655    +        %if &dsid %then %do;
105656    +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
105657    +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
105658    +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
105659    +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
105660    +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
105661    +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
105663    +          %let oldvar = ;
105664    +          %let obs = %sysfunc(fetch(&dsid));
105665    +          %do %while(&obs=0);
105666    +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
105667    +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
105668    +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
105669    +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
105670    +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
105671    +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
105673    +            %if "&oldvar" eq "&displayvar" %then %do;
105674    +              else
105675    +            %end;
105676    +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
105677    +               _SPLIT_VALUE_ = "&bin";
105678    +            end;
105679    +            %let oldvar = &displayvar;
105680    +            %let obs = %sysfunc(fetch(&dsid));
105681    +          %end;
105682    +        %end;
105683    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105684    +      run;
105686    +      proc sort data=&EM_USER_IMPORTSUBSET;
105687    +        by _VARIABLE_ _SPLIT_VALUE_;
105688    +      run;
105690    +      proc datasets library=work nolist;
105691    +        delete tempBinMappings;
105692    +      run;
105693    +      quit;
105694    +  %end;
105695    +%mend EM_IMPORT_BINNING;
105697    +%macro EM_FREEZE_BINNING(binningCode);
105699    +   data tempintfreeze;
105700    +     set &EM_USER_FREEZESUBSET;
105701    +     if binflag = 1;
105702    +   run;
105704    +   %let idsid = %sysfunc(open(work.tempintfreeze));
105705    +   %if &idsid %then %do;
105706    +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
105707    +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
105708    +   %end;
105709    +   %else %do;
105710    +     %let nvars = 0;
105711    +     %let nobs = 0;
105712    +   %end;
105713    +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
105715    +   proc datasets library=work nolist;
105716    +     delete tempintimport;
105717    +   run;
105718    +   quit;
105720    +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
105722    +      filename X "&binningCode";
105723    +      data _null_;
105724    +        FILE X MOD;
105726    +        %let bin_variables=.;
105727    +        %let quote_bin_variables=.;
105728    +        %let freeze_variables=;
105729    +        %let choice = binflag = 1;
105730    +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
105731    +        %if &dsid %then %do;
105732    +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
105733    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
105734    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
105735    +           %let vnum    = %sysfunc(VARNUM(&dsid, _variable_));
105737    +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingfrozenbins_note , NOQUOTE));
105738    +           put "&EM_CODEBAR;";
105739    +           put "&note;";
105740    +           put "&EM_CODEBAR;";
105742    +           /* retrieve value for first obs */
105743    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
105744    +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
105745    +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
105746    +           %let variable = %sysfunc(getvarc(&dsid, &vnum));
105748    +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
105749    +           %let i = 1;
105750    +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
105751    +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
105752    +           %end;
105753    +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
105754    +           %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
105756    +           put " ";
105757    +           put "if &oldname eq . then &binvalue = .;";
105759    +           /* cycle through special codes if they exist */
105760    +           %let index2 = %index(&oldname, SV_);
105761    +           %if &index2 gt 0 %then %do;
105762    +             %let choice = CODEVAR ="&oldname";
105763    +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
105764    +             %if &cdsid %then %do;
105765    +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
105766    +                %let cobs = %sysfunc(fetch(&cdsid));
105767    +                %do %while(&cobs=0);
105768    +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
105769    +                    put "else if &oldname eq &code then &binvalue = &code;";
105770    +                   %let cobs = %sysfunc(fetch(&cdsid));
105771    +                %end;
105772    +             %end;
105773    +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
105774    +           %end;
105775    +           put "else ";
105776    +           %if "&value" eq "." %then %do;
105777    +             put " &binvalue=&i;";
105778    +           %end;
105779    +           %else %do;
105780    +             put "  if &oldname < &value then &binvalue=&i;";
105781    +           %end;
105783    +           %let i= %eval(&i+1);
105785    +           %let obs = %sysfunc(fetch(&dsid));
105786    +           %do %while(&obs=0);
105787    +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
105788    +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
105789    +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
105790    +              %let variable = %sysfunc(getvarc(&dsid, &vnum));
105792    +              %if "&oldname" ne "&namevalue" %then %do;
105794    +                /* if variable has been re-coded for special codes, must include these values as well */
105795    +                put;
105796    +                put "if &namevalue eq . then &binvalue = .;";
105798    +                %let i=1;
105799    +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
105800    +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
105801    +                %end;
105802    +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
105803    +                %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
105805    +                /* cycle through special codes if they exist */
105806    +                %let index2 = %index(&namevalue, SV_);
105807    +                %if &index2 gt 0 %then %do;
105808    +                  %let choice = CODEVAR ="&namevalue";
105809    +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
105810    +                  %if &cdsid %then %do;
105811    +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
105812    +                     %let cobs = %sysfunc(fetch(&cdsid));
105813    +                     %do %while(&cobs=0);
105814    +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
105815    +                       put "else if &namevalue eq &code then &binvalue = &code;";
105816    +                       %let cobs = %sysfunc(fetch(&cdsid));
105817    +                     %end;
105818    +                  %end;
105819    +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
105820    +                %end;
105821    +                put "else ";
105822    +                %if "&value" ne "." %then %do;
105823    +                  put "  if &namevalue < &value then &binvalue=&i;";
105824    +                %end;
105825    +                %else %do;
105826    +                  put " &binvalue=&i;";
105827    +                %end;
105829    +              %end;
105830    +              %else %do;
105831    +                put "else ";
105832    +                %if "&value" ne "." %then %do;
105833    +                  put "  if &namevalue < &value then &binvalue=&i;";
105834    +                %end;
105835    +                %else %do;
105836    +                  put " &binvalue=&i;";
105837    +                %end;
105838    +              %end;
105839    +              %let i = %eval(&i + 1);
105840    +              %let obs = %sysfunc(fetch(&dsid));
105841    +              %let oldname = &namevalue;
105842    +              %let oldbinvalue = &binvalue;
105843    +           %end;
105844    +        %end;
105845    +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
105847    +      run;
105848    +      filename X;
105849    +      /* generate BINMAPPINGS dataset */
105850    +      data TEMPBINMAPPINGS;
105851    +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
105853    +        %let choice = binflag = 1;
105854    +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
105855    +        %if &dsid %then %do;
105856    +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
105857    +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
105858    +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
105859    +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
105860    +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
105862    +           /* retrieve information from first obs */
105863    +           %let obs = %sysfunc(fetchobs(&dsid, 1));
105864    +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
105865    +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
105866    +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
105867    +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar, 5));
105868    +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
105869    +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
105870    +           %let i = 1;
105872    +           NAME = "&OLDCODEVAR";
105873    +           BIN_NAME = "&OLDBINVAR";
105874    +           GRP_NAME = "&OLDGRPVAR";
105875    +           BIN = "&i";
105876    +           GRP = "&oldgrpvalue";
105877    +           LB = . ;
105878    +           UB = &oldvalue;
105879    +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
105880    +           DISPLAY_VAR = "&oldvar";
105881    +           output;
105883    +           %let i = 2;
105884    +           %let obs = %sysfunc(fetch(&dsid));
105885    +           %do %while(&obs=0);
105886    +             %let var = %sysfunc(getvarc(&dsid, &varnum));
105887    +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
105888    +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
105889    +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar, 5));
105890    +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
105891    +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
105893    +             %if "&oldvar" ne "&var" %then %do;
105895    +               %let i = 1;
105896    +               %let oldvalue = .;
105897    +             %end;
105899    +             NAME = "&CODEVAR";
105900    +             BIN_NAME = "&BINVAR";
105901    +             GRP_NAME = "&GRPVAR";
105902    +             BIN = "&i";
105903    +             GRP = "&group";
105904    +             LB = &oldvalue ;
105905    +             UB = &value;
105906    +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
105907    +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
105908    +             %end;
105909    +             %else %do;
105910    +               %if "&oldvalue" eq "." %then %do;
105911    +                 EM_BIN_LABEL = "&var < &value" ;
105912    +               %end;
105913    +               %if "&value" eq "." %then %do;
105914    +                 EM_BIN_LABEL = "&oldvalue <= &var";
105915    +               %end;
105916    +             %end;
105917    +             DISPLAY_VAR = "&var";
105918    +             output;
105920    +             %let oldvar = &var;
105921    +             %let oldcodevar = &codevar;
105922    +             %let oldbinvar = &binvar;
105923    +             %let oldgrpvar = &grpvar;
105924    +             %let oldvalue   = &value;
105925    +             %let oldgrpvalue = &group;
105926    +             %let i = %eval(&i + 1);
105927    +             %let obs = %sysfunc(fetch(&dsid));
105928    +           %end;
105929    +        %end;
105931    +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
105932    +      run;
105934    +      /* remove obs from EM_USER_BINMAPPINGS that have vars also in tempBinMappings -- prevents duplicate entries */
105935    +      data &EM_USER_BINMAPPINGS;
105936    +        set &EM_USER_BINMAPPINGS;
105937    +        if NAME in (&FREEZE_VARIABLES) then delete;
105938    +      run;
105940    +      data &EM_USER_BINMAPPINGS;
105941    +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
105943    +        set &EM_USER_BINMAPPINGS tempBinMappings;
105944    +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
105945    +      run;
105947    +      /* update freezesubset with bin values instead of raw values */
105948    +      data &EM_USER_FREEZESUBSET;
105949    +        set &EM_USER_FREEZESUBSET;
105951    +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
105952    +        %if &dsid %then %do;
105953    +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
105954    +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
105955    +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
105956    +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
105957    +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
105958    +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
105960    +          %let oldvar = ;
105961    +          %let obs = %sysfunc(fetch(&dsid));
105962    +          %do %while(&obs=0);
105963    +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
105964    +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
105965    +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
105966    +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
105967    +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
105968    +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
105970    +            %if "&oldvar" eq "&displayvar" %then %do;
105971    +              else
105972    +            %end;
105973    +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
105974    +               _SPLIT_VALUE_ = "&bin";
105975    +            end;
105976    +            %let oldvar =&displayvar;
105977    +            %let obs = %sysfunc(fetch(&dsid));
105978    +          %end;
105979    +        %end;
105980    +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
105981    +      run;
105983    +      proc sort data=&EM_USER_FREEZESUBSET;
105984    +        by _VARIABLE_ _SPLIT_VALUE_;
105985    +      run;
105987    +      proc datasets library=work nolist;
105988    +        delete tempBinMappings;
105989    +      run;
105990    +      quit;
105991    +   %end;
105992    +%mend EM_FREEZE_BINNING;
105994    +%macro EM_EQUAL_SPACED_BINNING(input, bindata, binningCode);
105997    +/* initialize new bucket_binning macro */
105998    +filename temp catalog 'sashelp.emapps.bucket_binning.source';
105999    +%include temp;
106000    +filename temp;
106002    +/* create fileref for generation of binningCode */
106003    +filename X "&binningCode";
106005    +/* determine if there are inputs to be binned */
106006    +%let numbinvars = 0;
106007    +%let intdsid = %sysfunc(open(work._intmid));
106008    +%if &intdsid %then %do;
106009    +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
106010    +%end;
106011    +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
106012    +%if &numbinvars > 0 %then %do;
106015    +/* get data in format needed for quantile_binning macro */
106016    +data work.vartable;
106017    +  set work._intmid;
106018    +  level = "INTERVAL";
106019    +  role  = "INPUT";
106020    +  rename variable=name;
106021    +run;
106023    +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
106024    +%if %EM_FREQ ne %then %do;
106025    +   data work.freq;
106026    +     name="%EM_FREQ";
106027    +     role="FREQ";
106028    +   run;
106030    +   data work.vartable;
106031    +     set work.vartable work.freq;
106032    +   run;
106033    +%end;
106035    +/* perform bucket binning of data */
106036    +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
106037    +%em_apps_bucket_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
106039    +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
106040    +%end;
106041    +%else %do;
106042    +  /* initialize binmappings table */
106043    +  data &EM_USER_BINMAPPINGS;
106044    +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
106045    +  run;
106047    +  data _null_;
106048    +    FILE X;
106050    +    put "&EM_CODEBAR;";
106051    +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
106052    +    put "* &note;";
106053    +    put "&EM_CODEBAR;";
106054    +  run;
106056    +%end;
106058    +/* assign display_var values to binmappings table as well as initial group values */
106059    +data &EM_USER_BINMAPPINGS;
106060    +  set &EM_USER_BINMAPPINGS;
106061    +  length display_var $32 grp $8;
106062    +  display_var = name;
106064    +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
106065    +    GRP = BIN + 1;
106066    +  %end;
106067    +  %else %do;
106068    +    GRP = BIN;
106069    +  %end;
106070    +run;
106072    +/* de-assign fileref */
106073    +filename X;
106075    +    /* append to binning code those values that were included in the importSubset data */
106076    +    %if &useImport eq 1 %then %do;
106077    +      %EM_IMPORT_BINNING(&binningcode);
106078    +    %end;
106080    +    /* append to binning code those values that were included in the freezeSubset data */
106081    +    %if &useFreeze eq 1 %then %do;
106082    +      %EM_FREEZE_BINNING(&binningcode);
106083    +    %end;
106085    +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
106086    +     by NAME;
106087    +     run;
106089    +     /* create grouping for missing level */
106090    +    data tempmissvalues;
106091    +    run;
106093    +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
106094    +       data tempmissvalues;
106095    +         %if &useImport eq 1 %then %do;
106096    +           merge sortedmapping &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME));
106097    +         %end;
106098    +         %if &useFreeze eq 1 %then %do;
106099    +           merge sortedmapping &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME));
106100    +         %end;
106101    +         %else %do;
106102    +           set sortedmapping;
106103    +         %end;
106104    +         GRP="1";
106105    +         bin="Missing";
106106    +         _split_value_ = "Missing";
106107    +         %if &useImport eq 1 %then %do;
106108    +            if _a then delete;
106109    +         %end;
106110    +         %if &useFreeze eq 1 %then %do;
106111    +            if _b then delete;
106112    +         %end;
106114    +       run;
106115    +    %end;
106117    +    /* create binData from binningCode */
106118    +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
106119    +      by NAME;
106120    +    run;
106122    +    filename X "&binningCode";
106123    +    data &bindata;
106124    +      set &input;
106125    +      %inc X;
106126    +    run;
106128    +    filename X;
106130    +    /* create splitvals dataset */
106131    +    data tempsplitvals;
106132    +      set &EM_USER_BINMAPPINGS
106133    +        %let tdsid = %sysfunc(open(work.tempmissvalues));
106134    +        %if &tdsid %then %do;
106135    +          tempmissvalues
106136    +        %end;
106137    +        %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
106138    +      ;
106139    +      length newgroup _group_ 8 _level_ $8;
106140    +      newgroup =.;
106141    +      _LEVEL_ = 'ORDINAL';
106142    +      _Group_ = grp;
106143    +      rename NAME=DISPLAY_VAR BIN=_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
106144    +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_;
106145    +    run;
106147    +    data tempsplitvals;
106148    +      set tempsplitvals;
106149    +      _order_ = _N_;
106150    +    run;
106152    +    /* determine if EM_USER_SPLITVALS already exists */
106153    +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
106154    +    %if &sdsid > 0 %then %do;
106155    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
106156    +      %if &nvars > 0 %then %do;
106157    +        proc sql;
106158    +          reset noprint;
106159    +          select count(*) into :nobs from &EM_USER_SPLITVALS;
106160    +        quit;
106161    +      %end;
106162    +      %else %let nobs=0;
106163    +    %end;
106164    +    %else %do;
106165    +       %let nobs=0;
106166    +       %let nvars=0;
106167    +    %end;
106168    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
106170    +    /* if useIMport=1 also include import definitions here as well */
106171    +    %if &useImport eq 1 %then %do;
106172    +      data tempImport;
106173    +        set &EM_USER_IMPORTSUBSET;
106174    +        _variable_ = binVar;
106175    +      run;
106176    +    %end;
106178    +    /* if useFreeze=1 also include import definitions here as well */
106179    +    %if &useFreeze eq 1 %then %do;
106180    +      data tempFreeze;
106181    +        length display_var $32;
106182    +        set &EM_USER_FREEZESUBSET;
106183    +        display_var = _variable_;
106184    +        _variable_ = binVar;
106185    +      run;
106186    +    %end;
106189    +    data &EM_USER_SPLITVALS;
106190    +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
106191    +        set &EM_USER_SPLITVALS tempsplitvals
106192    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
106193    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
106194    +        %end;
106195    +        %if &useFreeze eq 1 %then %do;
106196    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
106197    +        %end;
106198    +        ;
106199    +      %end;
106200    +      %else %do;
106201    +        set tempsplitvals
106202    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
106203    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
106204    +        %end;
106205    +        %if &useFreeze eq 1 %then %do;
106206    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
106207    +        %end;
106208    +        ;
106209    +      %end;
106210    +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _ORDER_;
106211    +    run;
106213    +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
106214    +    data tempvariableset;
106215    +      set &EM_DATA_VARIABLESET;
106216    +      where TYPE = 'C';
106217    +    run;
106219    +    /* add all interval vars that aren't special codes to the intervalvar macro
106220    +    %let dsid = %sysfunc(open(work.tempvariableset));
106221    +    %if &dsid %then %do;
106222    +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
106223    +      %let obs = %sysfunc(fetch(&dsid));
106224    +      %do %while(&obs=0);
106225    +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
106226    +        %let classvars = &classvars &varname;
106227    +        %let qclassvars = &qclassvars "&varname";
106228    +        %let obs = %sysfunc(fetch(&dsid));
106229    +      %end;
106230    +    %end;
106231    +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106232    +    */
106233    +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
106235    +    %if %classvars ne %then %do;
106236    +      proc dmdb data =&bindata classout=_classout nonorm;
106237    +        class %classvars;
106238    +      run;
106240    +      proc dmdb data=&bindata classout=_classout2;
106241    +       class %classvars;
106242    +      run;
106244    +      proc sort data=_classout; by NAME CRAW; run;
106245    +      proc sort data=_classout2; by NAME CRAW; run;
106247    +      data _classout;
106248    +        length _variable_ $32;
106249    +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
106250    +        _split_value_ = trim(left(_split_value_));
106251    +        LEVEL = trim(left(LEVEL));
106252    +        by NAME CRAW;
106253    +       _variable_ = NAME;
106254    +      run;
106256    +      proc sort data=_classout; by _variable_ _split_value_; run;
106257    +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
106259    +      data &EM_USER_SPLITVALS;
106260    +        length _norm_level_ $200 _split_value_ $200;
106261    +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
106262    +        by _variable_ _split_value_;
106263    +        LEVEL = trim(left(LEVEL));
106264    +        _norm_level_ = trim(left(_norm_level_));
106265    +        _split_value_ = trim(left(_split_value_));
106266    +        if _norm_level_ eq '' then _norm_level_= _split_value_;
106267    +        drop NAME FREQUENCY TYPE CRAW NRAW;
106268    +      run;
106270    +      proc datasets library=work nolist;
106271    +        delete _classout _classout2;
106272    +      run;
106273    +      quit;
106274    +    %end;
106275    +    data &EM_USER_SPLITVALS;
106276    +      set &EM_USER_SPLITVALS;
106277    +      if _norm_level_ eq '' then _norm_level_= _split_value_;
106278    +    run;
106280    +    proc sort data=&EM_USER_SPLITVALS;
106281    +      by DISPLAY_VAR _Group_;
106282    +    run;
106284    +   proc datasets library=work nolist;
106285    +     delete tempBinMappings temp_binmappings tempBinNames tempsplitvals sortedmapping tempmissvalues
106286    +      %if &useImport eq 1 %then %do;
106287    +        tempImport
106288    +      %end;
106289    +      %if &useFreeze eq 1 %then %do;
106290    +        tempFreeze
106291    +      %end;
106292    +     ;
106293    +   run;
106294    +   quit;
106296    +%mend;
106298    +%macro EM_QUANTILE_BINNING(input, pctdata, bindata, binningCode);
106300    +/* initialize new quantile_binning macro */
106301    +filename temp catalog 'sashelp.emapps.quantile_binning.source';
106302    +%include temp;
106303    +filename temp;
106305    +/* generate fileref for quantile_binning macro */
106306    +filename X "&binningCode";
106308    +/* determine if there are inputs to be binned */
106309    +%let numbinvars = 0;
106310    +%let intdsid = %sysfunc(open(work._intmid));
106311    +%if &intdsid %then %do;
106312    +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
106313    +%end;
106314    +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
106315    +%if &numbinvars > 0 %then %do;
106317    +/* get data in format needed for quantile_binning macro */
106318    +data work.vartable;
106319    +  set work._intmid;
106320    +  level = "INTERVAL";
106321    +  role  = "INPUT";
106322    +  rename variable=name;
106323    +run;
106325    +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
106326    +%if %EM_FREQ ne %then %do;
106327    +   data work.freq;
106328    +     name="%EM_FREQ";
106329    +     role="FREQ";
106330    +   run;
106332    +   data work.vartable;
106333    +     set work.vartable work.freq;
106334    +   run;
106335    +%end;
106338    +/* perform quantile binning of data */
106339    +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
106340    +%em_apps_quantile_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
106342    +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
106343    +%end;
106344    +%else %do;
106345    +  /* initialize binmappings table */
106346    +  data &EM_USER_BINMAPPINGS;
106347    +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
106348    +  run;
106350    +  data _null_;
106351    +    FILE X;
106353    +    put "&EM_CODEBAR;";
106354    +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
106355    +    put "* &note;";
106356    +    put "&EM_CODEBAR;";
106357    +  run;
106359    +%end;
106361    +/* assign display_var values to binmappings table as well as initial group values */
106362    +data &EM_USER_BINMAPPINGS;
106363    +  set &EM_USER_BINMAPPINGS;
106364    +  length display_var $32 grp $8;
106365    +  display_var = name;
106367    +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
106368    +    GRP = BIN + 1;
106369    +  %end;
106370    +  %else %do;
106371    +    GRP = BIN;
106372    +  %end;
106373    +run;
106375    +/* de-assign fileref */
106376    +filename X;
106378    +    /* append to binning code those values that were included in the importSubset data */
106379    +    %if &useImport eq 1 %then %do;
106380    +      %EM_IMPORT_BINNING(&binningcode);
106381    +    %end;
106383    +    /* append to binning code those values that were included in the freezeSubset data */
106384    +    %if &useFreeze eq 1 %then %do;
106385    +      %EM_FREEZE_BINNING(&binningcode);
106386    +    %end;
106388    +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
106389    +      by NAME;
106390    +    run;
106392    +    /* create grouping for missing level */
106393    +    data tempmissvalues;
106394    +    run;
106396    +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
106397    +       data tempmissvalues;
106398    +         %if ((&useImport eq 1) OR (&useFreeze eq 1)) %then %do;
106399    +           merge sortedmapping
106400    +           %if &useImport eq 1 %then %do;
106401    +              &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
106402    +           %end;
106403    +           %if &useFreeze eq 1 %then %do;
106404    +             &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
106405    +           %end;
106406    +           ;
106407    +         %end;
106408    +         %else %do;
106409    +           set sortedmapping;
106410    +         %end;
106411    +         GRP="1";
106412    +         bin="Missing";
106413    +         _split_value_ = "Missing";
106414    +         %if &useImport eq 1 %then %do;
106415    +            if _a then delete;
106416    +         %end;
106417    +         %if &useFreeze eq 1 %then %do;
106418    +            if _b then delete;
106419    +         %end;
106421    +       run;
106422    +    %end;
106425    +    /* create binData from binningCode */
106426    +    filename X "&binningCode";
106428    +    data &bindata;
106429    +      set &input;
106430    +      %inc X;
106431    +    run;
106433    +    filename X;
106435    +    /* create splitvals dataset */
106436    +    data tempsplitvals;
106437    +      set &EM_USER_BINMAPPINGS tempmissvalues;
106438    +      length newgroup _group_ _order_ 8 _level_ $8;
106439    +      newgroup =.;
106440    +      _LEVEL_ = 'ORDINAL';
106441    +      _Group_ = grp;
106442    +      rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
106443    +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
106444    +    run;
106446    +    data tempsplitvals;
106447    +      set tempsplitvals;
106448    +      _order_ = _N_;
106449    +    run;
106451    +    /* determine if EM_USER_SPLITVALS already exists */
106452    +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
106453    +    %if &sdsid > 0 %then %do;
106454    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
106455    +      %if &nvars > 0 %then %do;
106456    +        proc sql;
106457    +          reset noprint;
106458    +          select count(*) into :nobs from &EM_USER_SPLITVALS;
106459    +        quit;
106460    +      %end;
106461    +      %else %let nobs=0;
106462    +    %end;
106463    +    %else %do;
106464    +       %let nobs=0;
106465    +       %let nvars=0;
106466    +    %end;
106467    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
106469    +    /* if useIMport=1 also include import definitions here as well */
106470    +    %if &useImport eq 1 %then %do;
106471    +      data tempImport;
106472    +        set &EM_USER_IMPORTSUBSET;
106473    +        _variable_ = binVar;
106474    +      run;
106475    +    %end;
106477    +    /* if useFreeze=1 also include frozen definitions here as well */
106478    +    %if &useFreeze eq 1 %then %do;
106479    +      data tempFreeze;
106480    +        length display_var $32;
106481    +        set &EM_USER_FreezeSUBSET;
106482    +        display_var = _variable_;
106483    +        _variable_ = binVar;
106484    +      run;
106485    +    %end;
106487    +    data &EM_USER_SPLITVALS;
106488    +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
106489    +        set &EM_USER_SPLITVALS tempsplitvals
106490    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
106491    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
106492    +        %end;
106493    +        %if &useFreeze eq 1 %then %do;
106494    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
106495    +        %end;
106496    +        ;
106497    +      %end;
106498    +      %else %do;
106499    +        set tempsplitvals
106500    +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
106501    +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
106502    +        %end;
106503    +        %if &useFreeze eq 1 %then %do;
106504    +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
106505    +        %end;
106506    +        ;
106507    +      %end;
106508    +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
106509    +    run;
106511    +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
106512    +    data tempvariableset;
106513    +      set &EM_DATA_VARIABLESET;
106514    +      where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
106515    +    run;
106517    +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
106519    +    /* add all interval vars that aren't special codes to the intervalvar macro
106520    +    %let dsid = %sysfunc(open(work.tempvariableset));
106521    +    %if &dsid %then %do;
106522    +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
106523    +      %let obs = %sysfunc(fetch(&dsid));
106524    +      %do %while(&obs=0);
106525    +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
106526    +        %let classvars = &classvars &varname;
106527    +        %let qclassvars = &qclassvars "&varname";
106528    +        %let obs = %sysfunc(fetch(&dsid));
106529    +      %end;
106530    +    %end;
106531    +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106532    +*/
106533    +    %if %classvars ne %then %do;
106534    +      proc dmdb data =&bindata classout=_classout nonorm;
106535    +        class %classvars;
106536    +      run;
106538    +      proc dmdb data=&bindata classout=_classout2;
106539    +       class %classvars;
106540    +      run;
106542    +      proc sort data=_classout; by NAME CRAW; run;
106543    +      proc sort data=_classout2; by NAME CRAW; run;
106545    +      data _classout;
106546    +        length _variable_ $32;
106547    +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
106548    +        by NAME CRAW;
106549    +       _variable_ = NAME;
106550    +      run;
106552    +      proc sort data=_classout; by _variable_ _split_value_; run;
106553    +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
106555    +      data &EM_USER_SPLITVALS;
106556    +        length _norm_level_ $200 _split_value_ $200;
106557    +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
106558    +        by _variable_ _split_value_;
106559    +        LEVEL = trim(left(LEVEL));
106560    +        _split_value_ = trim(left(_split_value_));
106561    +        _norm_level_ = trim(left(_norm_level_));
106562    +        if _norm_level_ eq '' then _norm_level_= _split_value_;
106563    +        drop NAME FREQUENCY TYPE CRAW NRAW;
106564    +      run;
106566    +      proc datasets library=work nolist;
106567    +        delete _classout _classout2;
106568    +      run;
106569    +      quit;
106570    +    %end;
106572    +    data &EM_USER_SPLITVALS;
106573    +      set &EM_USER_SPLITVALS;
106574    +      if _norm_level_ eq '' then _norm_level_= _split_value_;
106575    +    run;
106578    +    proc sort data=&EM_USER_SPLITVALS;
106579    +      by DISPLAY_VAR _Group_;
106580    +    run;
106582    +    proc datasets library=work nolist;
106583    +      delete sortedmapping tempsplitvals tempmissvalues
106584    +      %if &useImport eq 1 %then %do;
106585    +        tempImport
106586    +      %end;
106587    +      %if &useFreeze eq 1 %then %do;
106588    +        tempFreeze
106589    +      %end;
106590    +      ;
106591    +    run;
106592    +    quit;
106593    +/*
106594    +%end;
106595    +%else %do;
106596    +    data &bindata;
106597    +      set &input;
106598    +    run;
106599    +%end;
106600    +*/
106601    +%mend EM_QUANTILE_BINNING;
106603    +%macro EM_ORDVARS_GROUP;
106605    +   /* retrieve all ordinal variables from the incoming dataset */
106606    +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
106607    +     by NAME;
106608    +     where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
106609    +   run;
106611    +   /* add all vars marked as interval that are actually class vars to this data */
106612    +   %let nobs = 0;
106613    +   %let dsid = %sysfunc(open(WORK._DISCRETEMID));
106614    +   %if &dsid %then %do;
106615    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106616    +     %if &nobs gt 0 %then %do;
106618    +     data tempvars;
106619    +       set &EM_DATA_VARIABLESET;
106620    +       if NAME in (
106621    +         %let obs = %sysfunc(fetch(&dsid));
106622    +         %do %while(&obs=0);
106623    +           %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
106624    +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
106625    +           "&varname"
106626    +           %let obs = %sysfunc(fetch(&dsid));
106627    +         %end;
106628    +        );
106629    +     run;
106630    +     data tempvariableset;
106631    +       set tempvariableset tempvars;
106632    +     run;
106633    +     %end;
106634    +   %end;
106635    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106637    +   %if &useImport eq 1 %then %do;
106638    +     /* remove all variables from tempvariableset that are included in the importsubset */
106639    +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
106640    +       by _VARIABLE_ ;
106641    +     run;
106642    +     proc sort data=tempvariableset; by NAME; run;
106644    +     data tempvariableset;
106645    +       merge tempimport(in=_a) tempvariableset(in=_b);
106646    +       by NAME;
106647    +       if ^_a then output;
106648    +     run;
106649    +   %end;
106651    +   %if &useFreeze eq 1 %then %do;
106652    +     /* remove all variables from tempvariableset that are included in the freezesubset */
106653    +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
106654    +       by _VARIABLE_ ;
106655    +     run;
106656    +     proc sort data=tempvariableset; by NAME; run;
106658    +     data tempvariableset;
106659    +       merge tempfreeze(in=_a) tempvariableset(in=_b);
106660    +       by NAME;
106661    +       if ^_a then output;
106662    +     run;
106663    +   %end;
106665    +   /* get dataset of distinct values for the ordinal variable */
106666    +   %let nobs = 0;
106667    +   %let dsid = %sysfunc(open(WORK.tempvariableset));
106668    +   %if &dsid %then %do;
106669    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106670    +     %if &nobs gt 0 %then %do;
106671    +         %let obs = %sysfunc(fetch(&dsid));
106672    +         %do %while(&obs=0);
106673    +           %let varnum = %sysfunc(VARNUM(&dsid, NAME));
106674    +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
106675    +           %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
106676    +           %let input_type = %sysfunc(getvarc(&dsid, &typenum));
106677    +           %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
106678    +           %let input_fmt = %sysfunc(getvarc(&dsid, &fmtnum));
106679    +           %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
106680    +           %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
106681    +           %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
106683    +           data temp;
106684    +             set &EM_USER_BINDATA(keep=&varname);
106685    +             %if &input_fmt ne %then %do;
106686    +               %dmnormcp(put(&varname, &input_fmt), _norm);
106687    +             %end;
106688    +             %else %do;
106689    +               %dmnormcp(&varname, _norm);
106690    +             %end;
106691    +             keep &varname _norm;
106692    +           run;
106694    +          proc dmdb data=temp classout=_classout2;
106695    +           class _norm;
106696    +         run;
106697    +         proc sort data=_classout2; by LEVEL; run;
106699    +         /* re-order numeric inputs based on non-normalized values */
106700    +         %if &input_type eq N %then %do;
106701    +           proc sort data=temp nodupkey; by _norm; run;
106702    +           data varvals;
106703    +             merge temp _classout2(rename=(LEVEL=_norm));
106704    +             by _norm;
106705    +             if craw='' and _norm ne '.' then delete;
106706    +             keep &varname _norm nraw craw;
106707    +           run;
106709    +           proc sort data=varvals; by &varname; run;
106710    +         %end;
106711    +         %else %do;
106712    +           data varvals;
106713    +              set _classout2(rename=(LEVEL=_norm));
106714    +              if _norm='' then delete;
106715    +              if _norm='.' then delete;
106716    +              keep _norm;
106717    +           run;
106718    +         %end;
106719    +         data varvals;
106720    +           set varvals;
106721    +           if &varname="." then delete;
106722    +           if upcase(&varname) = "MISSING" then delete;
106723    +         run;
106725    +          /* generate Splitvals Data */
106726    +          data tempsplitvals;
106727    +            length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ _order_ 8 _level_ $8 _norm_level_ $200 ;
106729    +            %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
106730    +              DISPLAY_VAR="&varname";
106731    +              _VARIABLE_ ="&varname";
106732    +              newgroup   =.;
106733    +              _group_    =1;
106734    +              _Split_Value_="Missing";
106735    +              _level_    ="ORDINAL";
106736    +              output;
106737    +              %let group=2;
106738    +            %end;
106739    +            %else %let group=1;
106741    +            %let vdsid = %sysfunc(open(WORK.VARVALS));
106742    +            %if &vdsid %then %do;
106743    +            %let namenum = %sysfunc(VARNUM(&vdsid, _norm));
106744    +            /*%let group = 2;*/
106745    +            %let vobs = %sysfunc(fetch(&vdsid));
106746    +            %do %while(&vobs=0);
106747    +                %let nameval = %bquote(%upcase(%sysfunc(getvarc(&vdsid, &namenum))));
106749    +                DISPLAY_VAR   = "&varname";
106750    +                _variable_    = "&varname";
106751    +                newgroup      = .;
106752    +                _group_       = &group;
106753    +                _split_value_ = "&nameval";
106754    +                _level_       = 'ORDINAL';
106755    +                output;
106757    +              %let group = %eval(&group + 1);
106758    +              %let vobs = %sysfunc(fetch(&vdsid));
106759    +            %end;
106760    +            %if &vdsid %then %let vdsid = %sysfunc(close(&vdsid));
106761    +          run;
106763    +          /* determine if EM_USER_SPLITVALS already exists */
106764    +          %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
106765    +          %if &sdsid > 0 %then %do;
106766    +            %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
106767    +            %if &nvars > 0 %then %do;
106768    +               proc sql;
106769    +                reset noprint;
106770    +                select count(*) into :nobs from &EM_USER_SPLITVALS;
106771    +               quit;
106772    +            %end;
106773    +            %else %let nobs=0;
106774    +            %end;
106775    +            %else %do;
106776    +              %let nobs=0;
106777    +              %let nvars=0;
106778    +            %end;
106779    +          %end;
106780    +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
106782    +          /* if tempsplitvals doesn't exist; create empty data set */
106783    +          %let sdsid = %sysfunc(open(work.tempsplitvals));
106784    +          %if &sdsid <= 0 %then %do;
106785    +            data tempsplitvals;
106786    +              length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ 8 _level_ $8 ;
106787    +            run;
106788    +          %end;
106789    +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
106791    +          data tempsplitvals;
106792    +            set tempsplitvals;
106793    +            _order_ = _N_;
106794    +          run;
106796    +          %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
106797    +             proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
106798    +             proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
106799    +          %end;
106801    +          data &EM_USER_SPLITVALS;
106802    +           %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
106803    +             merge &EM_USER_SPLITVALS tempsplitvals;
106804    +             by _variable_ _split_value_;
106805    +           %end;
106806    +           %else %do;
106807    +             set tempsplitvals;
106808    +           %end;
106809    +           if display_var eq "" then delete;
106810    +           if _norm_level_ eq "" then _norm_level_ = _split_value_;
106811    +           keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_ _order_;
106812    +         run;
106814    +           %let obs = %sysfunc(fetch(&dsid));
106815    +         %end;
106816    +     %end;
106817    +   %end;
106818    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106820    +   proc sort data=&EM_USER_SPLITVALS;
106821    +      by DISPLAY_VAR _Group_;
106822    +   run;
106824    +   /* delete temporary datasets */
106825    +   proc datasets library= work nolist;
106826    +     delete tempsplitvals varvals tempvariableset tempvars
106827    +     ;
106828    +   run;
106829    +   quit;
106830    +%mend EM_ORDVARS_GROUP;
106833    +%macro EM_CLASSVARS_GROUP(groupRare);
106835    +   /* retrieve all class variables from the incoming dataset */
106836    +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
106837    +     by NAME;
106838    +     where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
106839    +   run;
106841    +   %if &useImport eq 1 %then %do;
106842    +     /* remove all variables from tempvariableset that are included in the importsubset */
106843    +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
106844    +       by _VARIABLE_ ;
106845    +     run;
106846    +     proc sort data=tempvariableset; by NAME; run;
106848    +     data tempvariableset;
106849    +       merge tempimport(in=_a) tempvariableset(in=_b);
106850    +       by NAME;
106851    +       if ^_a then output;
106852    +     run;
106853    +   %end;
106855    +   %if &useFreeze eq 1 %then %do;
106856    +     /* remove all variables from tempvariableset that are included in the freezesubset */
106857    +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
106858    +       by _VARIABLE_ ;
106859    +     run;
106860    +     proc sort data=tempvariableset; by NAME; run;
106862    +     data tempvariableset;
106863    +       merge tempfreeze(in=_a) tempvariableset(in=_b);
106864    +       by NAME;
106865    +       if ^_a then output;
106866    +     run;
106867    +   %end;
106869    +   /* run dmdb to retrieve list of all class levels and counts */
106870    +   %let dsid = %sysfunc(open(work.tempvariableset));
106871    +   %let nobs = 0;
106872    +   %if &dsid %then %do;
106873    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106875    +   %end;
106877    +   %if &nobs gt 0 %then %do;
106878    +     proc dmdb data=&EM_IMPORT_DATA classout=tempclassout;
106879    +       class
106881    +        %let namenum = %sysfunc(VARNUM(&dsid, NAME));
106882    +        %let obs = %sysfunc(fetch(&dsid));
106883    +        %do %while(&obs=0);
106884    +           %let name = %sysfunc(getvarc(&dsid, &namenum));
106885    +           &name
106886    +           %let obs = %sysfunc(fetch(&dsid));
106887    +        %end;
106888    +     ;
106890    +     %if %EM_FREQ ne %then %do;
106891    +        freq %EM_FREQ;
106892    +     %end;
106893    +    run;
106894    +   %end;
106895    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106897    +   %let dsid = %sysfunc(open(work.tempclassout));
106898    +   %let nobs = 0;
106899    +   %if &dsid %then %do;
106900    +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
106901    +     %let dsid = %sysfunc(close(&dsid));
106902    +   %end;
106904    +   %if &nobs gt 0 %then %do;
106905    +    data tempclassout;
106906    +       set tempclassout;
106907    +       if LEVEL='MISSING' then level='Missing';
106908    +    run;
106910    +    proc sort data=tempclassout nodupkey;
106911    +      by NAME descending FREQUENCY LEVEL;
106912    +    run;
106914    +    data tempds(keep=NAME NOBS);
106915    +      retain NOBS;
106916    +      set tempclassout;
106917    +      by NAME;
106918    +      if first.NAME then
106919    +        NOBS = frequency;
106920    +      else
106921    +        NOBS=NOBS+frequency;
106922    +      if last.name then do;
106923    +        output;
106924    +      end;
106925    +    run;
106927    +    data tempds;
106928    +      merge tempclassout
106929    +      tempds;
106930    +      by NAME;
106931    +      if ((LEVEL ne '') AND (LEVEL ne "."));
106932    +      %if &groupRare eq Y %then %do;
106933    +        PCT = 100 * (FREQUENCY/NOBS);
106934    +        if PCT < &EM_PROPERTY_GROUPCUTOFF then flag=1;
106935    +        else flag=0;
106936    +      %end;
106937    +      %else %do;
106938    +        flag = 0;
106939    +      %end;
106940    +    run;
106942    +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
106943    +      data tempmissvalues;
106944    +        length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
106946    +      %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
106947    +      %if &dsid %then %do;
106948    +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
106949    +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
106950    +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
106951    +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
106952    +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
106953    +        %let obs = %sysfunc(fetch(&dsid));
106955    +        %do %while(&obs=0);
106956    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
106957    +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
106958    +          %let type = %sysfunc(getvarc(&dsid, &typenum));
106959    +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
106961    +          NAME="&var";
106962    +          LEVEL="Missing";
106963    +          _LEVEL_="&varlvl";
106964    +          _group_ = 1;
106965    +          output;
106967    +          %let obs = %sysfunc(fetch(&dsid));
106968    +        %end;
106969    +      %end;
106970    +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
106971    +      run;
106972    +    %end;
106974    +    /* generate Splitvals Data */
106975    +    data tempsplitvals;
106976    +      length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
106978    +      set tempclassout
106979    +      %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
106980    +         tempmissvalues
106981    +      %end;
106982    +      ;
106983    +      if ((level ne '') AND (level ne '.'));
106985    +     %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
106986    +     %if &dsid %then %do;
106987    +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
106988    +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
106989    +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
106990    +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
106991    +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
106992    +        %let obs = %sysfunc(fetch(&dsid));
106994    +        %do %while(&obs=0);
106995    +          %let var = %sysfunc(getvarc(&dsid, &varnum));
106996    +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
106997    +          %let type = %sysfunc(getvarc(&dsid, &typenum));
106998    +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
107000    +          if NAME = "&var" then do;
107001    +            _LEVEL_ = "&varlvl";
107003    +          /* cycle through levels, assigning group values;              */
107004    +          /* flag=1 indicates to put value in "_OTHER_" group;          */
107005    +          /* flag=0 indicates that value shoudld be in group of its own */
107006    +          %let choice = ((NAME="&Var") and (FLAG=0));
107007    +          %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
107008    +            %let group=2;
107009    +          %end;
107010    +          %else %do;
107011    +            %let group = 1;
107012    +          %end;
107013    +          %let fdsid = %sysfunc(open(work.tempds(where=(&choice))));
107014    +          %if &fdsid %then %do;
107016    +            %let lvlnum = %sysfunc(VARNUM(&fdsid, LEVEL));
107017    +            %let fobs = %sysfunc(fetch(&Fdsid));
107018    +            %let fflag = 0;
107019    +            %do %while(&fobs=0);
107020    +              %let fflag = 1;
107021    +              %let temp = %nrbquote(%sysfunc(getvarc(&fdsid, &lvlnum)));
107022    +              %let level = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
107023    +              %let level = %nrbquote(%sysfunc(strip(&level)));
107024    +              %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
107025    +                %if &group eq 2 %then %do;
107026    +                   if LEVEL = "&level" then _GROUP_ = &group;
107027    +                %end;
107028    +                %else %do;
107029    +                   else if LEVEL = "&level" then _GROUP_ = &group;
107030    +                %end;
107031    +              %end;
107032    +              %else %do;
107033    +                %if &group eq 1 %then %do;
107034    +                   if LEVEL = "&level" then _GROUP_ = &group;
107035    +                %end;
107036    +                %else %do;
107037    +                   else if LEVEL = "&level" then _GROUP_ = &group;
107038    +                %end;
107039    +              %end;
107041    +              %let group = %eval(&group + 1);
107042    +              %let fobs = %sysfunc(fetch(&fdsid));
107043    +            %end;
107045    +          %end;
107046    +          %if &fflag eq 1 %then %do;
107047    +            else if LEVEL ^='Missing' then _GROUP_ = &group;
107048    +          %end;
107049    +          end;
107051    +          %if &fdsid %then %let fdsid = %sysfunc(close(&fdsid));
107052    +          %let obs = %sysfunc(fetch(&dsid));
107053    +        %end;
107054    +     %end;
107055    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
107056    +     _VARIABLE_ = NAME;
107057    +     newgroup = .;
107058    +     rename NAME = DISPLAY_VAR
107059    +            LEVEL = _SPLIT_VALUE_;
107060    +     keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
107061    +    run;
107062    +  %end;
107063    +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
107065    +    /* determine if EM_USER_SPLITVALS already exists */
107066    +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
107067    +    %if &sdsid > 0 %then %do;
107068    +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
107069    +      %if &nvars > 0 %then %do;
107070    +        proc sql;
107071    +          reset noprint;
107072    +          select count(*) into :nobs from &EM_USER_SPLITVALS;
107073    +        quit;
107074    +      %end;
107075    +      %else %let nobs=0;
107076    +    %end;
107077    +    %else %do;
107078    +       %let nobs=0;
107079    +       %let nvars=0;
107080    +    %end;
107081    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
107083    +   /* if tempsplitvals doesn't exist; create empty data set */
107084    +    %let sdsid = %sysfunc(open(work.tempsplitvals));
107085    +    %if &sdsid <= 0 %then %do;
107086    +      data tempsplitvals;
107087    +        length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
107088    +      run;
107089    +    %end;
107090    +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
107092    +    %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
107093    +      proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
107094    +      proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
107095    +    %end;
107097    +    /* if useIMport=1 also include import definitions here as well */
107098    +    %if &useImport eq 1 %then %do;
107099    +      proc sort data=&EM_USER_IMPORTSUBSET; by _variable_ _split_value_; run;
107100    +    %end;
107101    +    %if &useFreeze eq 1 %then %do;
107102    +      proc sort data=&EM_USER_FREEZESUBSET; by _variable_ _split_value_; run;
107103    +    %end;
107104    +    data &EM_USER_SPLITVALS;
107105    +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
107106    +        merge &EM_USER_SPLITVALS tempsplitvals
107107    +        %if &useImport eq 1 %then %do;
107108    +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
107109    +        %end;
107110    +        %if &useFreeze eq 1 %then %do;
107111    +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
107112    +        %end;
107114    +        ;
107115    +        by _variable_ _split_value_
107116    +        ;
107117    +      %end;
107118    +      %else %do;
107119    +        set tempsplitvals
107120    +        %if &useImport eq 1 %then %do;
107121    +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
107122    +        %end;
107123    +        %if &useFreeze eq 1 %then %do;
107124    +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
107125    +        %end;
107126    +        ;
107127    +      %end;
107128    +      if display_var eq "" then delete;
107129    +      if _norm_level_ eq "" then _norm_level_ = _split_value_;
107130    +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
107131    +    run;
107133    +    proc sort data=&EM_USER_SPLITVALS;
107134    +      by DISPLAY_VAR _Group_;
107135    +    run;
107137    +   /* delete temporary datasets */
107138    +   proc datasets library= work nolist;
107139    +     delete tempsplitvals tempds tempclassout tempvariableset tempvars
107140    +     %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
107141    +       tempmissvalues
107142    +     %end;
107143    +     ;
107144    +   run;
107145    +   quit;
107146    +%mend EM_CLASSVARS_GROUP;
107149    +%macro EM_SUMMARIZE_TABLE(data, inputData, outData, varname=);
107151    +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
107153    +  data temptrain ;
107154    +    set &data;
107155    +  run;
107157    +  /* normalize all values prior to calculating counts */
107158    +  filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
107159    +  %include _temp;
107160    +  filename _temp;
107161    +  filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
107162    +  %include _temp;
107163    +  filename _temp;
107165    +  proc sort data=&EM_USER_VARMAPPINGS
107166    +  %if &varname ne %then %do;
107167    +    (where=(_variable_="&varname"))
107168    +  %end;
107169    +  out=tempmap; by _variable_; run;
107171    +  data _cmeta;
107172    +    merge tempvarset tempmap(in=_a rename=(_variable_=name ));
107173    +    by name;
107174    +    if ((_a) or (role="TARGET"));
107175    +    if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
107176    +    %if %length(%EM_BINARY_TARGET) %then %do;
107177    +      if role="TARGET" then role="INPUT";
107178    +    %end;
107179    +    level = procLevel;
107180    +    index = kindex(name, "BIN_");
107181    +    if index gt 0 then do;
107182    +     level="ORDINAL";
107183    +     format = "";
107184    +    end;
107185    +    drop index;
107186    +  run;
107188    +  %em_PreNormalizeClassVars(incmeta=_cmeta, outcmeta=_cmetatmp);
107189    +  %em_NormalizeClassVars(indata=work.temptrain, cmeta=_cmetatmp, encodedTarget=N, outdata=_tmp_train);
107191    +  proc sort data=&inputData out=sortedmap; by _proc_var_; run;
107193    +  data _null_;
107194    +    set sortedmap end=eof;
107195    +    by _proc_var_;
107196    +    if _n_=1 then do;
107197    +      call execute("ods output CrossTabFreqs=crosstabfreq ;");
107198    +      call execute("ods listing close;");
107199    +      call execute("proc freq data=_tmp_train order=formatted addnames;");
107200    +      call execute("tables ("||_proc_var_);
107201    +    end;
107202    +    else do;
107203    +      call execute(_proc_var_);
107204    +    end;
107205    +    if eof then do;
107206    +      call execute(") * &ignbintarget/ missing;");
107207    +      %if %EM_FREQ ne %then %do;
107208    +        call execute("weight %EM_FREQ;");
107209    +      %end;
107210    +      call execute("run;");
107211    +      call execute("ods output close;");
107212    +      call execute("ods listing;");
107213    +    end;
107214    +  run;
107216    +  data _null_;
107217    +    set sortedmap end=eof;
107218    +    by _proc_var_;
107219    +    if _n_=1 then do;
107220    +      call execute("data crosstabs;");
107221    +      call execute("  length _variable_ _split_value_  $200 ;");
107222    +      call execute("  set crosstabfreq(where=(_type_='11'));");
107223    +      call execute("  _variable_= RowVariable;");
107224    +    end;
107226    +    call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
107227    +    call execute("  _split_value_="||_proc_var_||";");
107228    +    call execute("end;");
107230    +    if eof then do;
107231    +      call execute("keep _variable_ _split_value_ &ignbintarget Frequency Percent display_var;");
107232    +      call execute("run;");
107233    +    end;
107234    +  run;
107236    +  proc sort data=crosstabs; by _variable_ _split_value_; run;
107238    +  data crosstabs;
107239    +    length display_var $32;
107240    +    merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
107241    +    by _variable_;
107242    +  run;
107244    +  proc sort data=crosstabs; by display_var _split_value_; run;
107245    +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
107247    +  data crosstabs;
107248    +    merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
107249    +    by display_var;
107250    +    index = kindex(_variable_, "BIN_");
107251    +    if index gt 0 then do;
107252    +     level="ORDINAL";
107253    +     format = "";
107254    +    end;
107255    +    _temp = &ignbintarget;
107256    +    /*
107257    +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
107258    +      %if &target_format ne %then %do;
107259    +        %if &target_type eq C %then %do;
107260    +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
107261    +        %end;
107262    +        %else %do;
107263    +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
107264    +        %end;
107265    +      %end;
107266    +      %else %do;
107267    +        %dmnormcp(&ignbintarget, _temp);
107268    +      %end;
107269    +    %end;
107270    +    %else %do;
107271    +      _temp = &ignbintarget;
107272    +    %end;
107273    +*/
107275    +    drop index;
107276    +  run;
107278    +  proc sort data=crosstabs; by _variable_ _split_value_; run;
107280    +  data &outdata;
107281    +    length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate  8 type $1 valfmt $20 ;
107283    +    retain eventCount noneventCount ;
107284    +    set crosstabs;
107285    +    by  _variable_ _split_value_;
107287    +    if first._split_value_ then do;
107288    +     total=0;
107289    +     eventcount=0;
107290    +     noneventcount=0;
107291    +    end;
107293    +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
107294    +      %if &target_format ne %then %do;
107295    +        if upcase(strip(_temp))="&target_event" then
107296    +          eventCount=Frequency;
107297    +      %end;
107298    +      %else %do;
107299    +         if upcase(strip(_temp)) ="&target_event" then
107300    +          eventCount=Frequency;
107301    +      %end;
107302    +    %end;
107303    +    %else %do;
107304    +      if _temp=&target_event then
107305    +        eventCount=Frequency;
107306    +    %end;
107307    +    else
107308    +      noneventCount=Frequency;
107310    +    if last._split_value_ then do;
107311    +      total = eventCount + noneventCount;
107313    +      if total ne 0 then do;
107314    +        eventRate = eventCount / total;
107315    +        nonEventRate = nonEventCount / total;
107316    +      end;
107317    +      else do;
107318    +        eventRate = 0;
107319    +        nonEventRate = 0;
107320    +      end;
107321    +     output;
107322    +    end;
107323    +    valfmt = format;
107325    +    drop _temp Frequency percent;
107326    +   run;
107328    +%mend EM_SUMMARIZE_TABLE;
107331    +%macro EM_FINE_DETAIL(bindata, varmappings, fineDetailData, splitVals, binMappings, interactiveFlag=0);
107333    +   proc freq data=&bindata noprint;
107334    +     table &ignbintarget / missing out=temptargetB;
107335    +     %if %EM_FREQ ne %then %do;
107336    +       weight %EM_FREQ;
107337    +     %end;
107338    +   run;
107340    +   %let tdsid = %sysfunc(open(work.temptargetB));
107341    +   %if &tdsid %then %do;
107342    +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
107343    +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
107345    +      %let temp = %nrbquote(%sysfunc(strip(&target_event)));
107346    +      %let target_event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
107347    +      %let temp = %nrbquote(%sysfunc(strip(&target_nonevent)));
107348    +      %let target_nonevent = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
107351    +      %let obs = %sysfunc(fetch(&tdsid));
107352    +      %do %while(&obs = 0);
107353    +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
107354    +           %if &target_type eq C %then %do;
107355    +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
107356    +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
107357    +           %end;
107358    +           %else
107359    +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
107361    +           %if &target_format ne %then %do;
107362    +              %if &target_type eq C %then %do;
107363    +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
107364    +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
107365    +              %end;
107366    +              %else
107367    +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
107368    +           %end;
107369    +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
107370    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
107372    +           %if "&tarvalue" eq "&target_event" %then %do;
107373    +             %let totalevent = &count;
107374    +           %end;
107375    +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
107376    +              %let totalnonevent= &count;
107377    +           %end;
107378    +         %end;
107379    +         %else %do;
107380    +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
107381    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
107383    +           %if &tarvalue eq &target_event %then %do;
107384    +             %let totalevent = &count;
107385    +           %end;
107386    +           %else %if &tarvalue eq &target_nonevent %then %do;
107387    +              %let totalnonevent= &count;
107388    +           %end;
107389    +         %end;
107390    +         %let obs = %sysfunc(fetch(&tdsid));
107391    +      %end;
107392    +   %end;
107393    +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
107395    +   proc datasets lib=work nolist;
107396    +      delete temptargetB;
107397    +   run;
107398    +   quit;
107400    +   %if &interactiveFlag eq 0 %then %do;
107401    +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData);
107402    +   %end;
107403    +   %else %do;
107404    +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData, varname=&wherevar);
107405    +   %end;
107408    +   data &fineDetailData;
107409    +     length display_var $32 newgroup numsplitval 8;
107410    +     set &fineDetailData;
107412    +     display_var = _variable_;
107414    +     index = kindex(display_var, "BIN_");
107415    +     if index gt 0 then do;
107416    +       display_var = ksubstr(display_var, 5);
107417    +     end;
107419    +     index2 = kindex(display_var, "SV_");
107420    +     if index2 gt 0 then do;
107421    +       display_var = ksubstr(display_var, 4);
107422    +     end;
107424    +     /* re-code missing values to "Missing" */
107425    +     if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
107426    +     _index_ = _N_;
107427    +     newgroup = .;
107428    +     drop index index2 ;
107429    +   run;
107431    +   /* add group information to fineDetailData; */
107432    +   /* add label information for binned variables to fineDetailData*/
107434    +   proc sort data=&fineDetailData; by _variable_ _split_value_; run;
107436    +   data tmpsplitvals;
107437    +     set &splitvals;
107438    +     _norm_level_ = upcase(_norm_level_);
107439    +     if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
107440    +    * drop _split_value_;
107441    +   run;
107443    +   proc sort data=tmpsplitvals out=sortedsplit; by _variable_ _split_value_; run;
107444    +   proc datasets library=work nolist;
107445    +     delete tmpsplitvals;
107446    +   run;
107447    +   quit;
107449    +   proc sort data=&BINMAPPINGS out=sortedbin; by BIN_NAME BIN; run;
107451    +   data &fineDetailData;
107452    +      merge &fineDetailData(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
107453    +      by _variable_ _split_value_;
107454    +      if _a then do;
107455    +        binFlag = 1;
107456    +        VALUE=EM_BIN_LABEL;
107457    +      end;
107458    +      else do;
107459    +        binFlag = 0;
107460    +        *VALUE=strip(display_var)!!"="!!strip(_split_value_);
107461    +        VALUE=strip(_split_value_);
107463    +      end;
107465    +      if ((eventCount=.) or (nonEventCount=.)) then do;
107466    +        eventCount=0;
107467    +        nonEventCount=0;
107468    +        total = 0;
107469    +        eventRate= 0;
107470    +        nonEventRate = 0;
107471    +      end;
107473    +      eventCount = round(eventCount, .001);
107474    +      nonEventCount = round(nonEventCount, .001);
107475    +      total= round(total, .001);
107476    +      eventRate = round(eventRate, .001);
107477    +      nonEventRate = round(nonEventRate, .001);
107479    +     if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then
107480    +         numsplitval = _split_value_;
107481    +     else if ((type='N') AND (valfmt ne "")) then
107482    +        numsplitval = _order_;
107483    +     else numsplitval=.;
107485    +      if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
107486    +      if _a and ^_b then delete;
107487    +      if _c and ^_b then delete;
107488    +      drop NAME EM_BIN_LABEL valfmt;
107489    +   run;
107491    +   /* for class variables that have values falling into the "other" category, set _LEVEL_ and _GROUP_ based on Missing level */
107492    +   data &fineDetailData;
107493    +     set &fineDetailData;
107495    +     %let choice = _LEVEL_ ne "INTERVAL" and _SPLIT_VALUE_ eq "Missing";
107496    +     %let dsid = %sysfunc(open(&splitvals(where=(&choice))));
107497    +     %if &dsid %then %do;
107498    +       %let dnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
107499    +       %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
107500    +       %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
107502    +       %let obs = %sysfunc(fetch(&dsid));
107503    +       %do %while(&obs=0);
107504    +         %let dispvar = %sysfunc(getvarc(&dsid, &dnum));
107505    +         %let lvl     = %sysfunc(getvarc(&dsid, &lvlnum));
107506    +         %let group   = %sysfunc(getvarn(&dsid, &grpnum));
107508    +         if DISPLAY_VAR = "&dispvar" then do;
107509    +           if _LEVEL_ = "" then _LEVEL_ ="&lvl";
107510    +           if _GROUP_ = . then _GROUP_ = &group;
107511    +         end;
107513    +         %let obs = %sysfunc(fetch(&dsid));
107514    +       %end;
107515    +     %end;
107516    +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
107517    +     if _GROUP_ = . then delete;
107518    +    * if binFlag=1 and UB=LB then delete;
107519    +    * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
107520    +   run;
107522    +   proc sort data=&fineDetailData;
107523    +     by DISPLAY_VAR _index_;
107524    +   run;
107526    +   proc datasets lib=work nolist;
107527    +     delete sortedsplit sortedbin
107528    +     ;
107529    +   run;
107530    +   quit;
107531    +%mend EM_FINE_DETAIL;
107533    +%macro EM_CREATE_GROUPING(bindata, fineDetailData, coarse);
107535    +   proc freq data=&bindata noprint;
107536    +     table &ignbintarget / missing out=temptargetC;
107537    +     %if %EM_FREQ ne %then %do;weight %EM_FREQ;
107538    +     %end;
107539    +   run;
107541    +   %let tdsid = %sysfunc(open(work.temptargetC));
107542    +   %if &tdsid %then %do;
107543    +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
107544    +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
107546    +      %let obs = %sysfunc(fetch(&tdsid));
107547    +      %do %while(&obs = 0);
107548    +        /* %if &target_type eq C or &target_format ne %then %do; */
107549    +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
107550    +           %if &target_type eq C %then %do;
107551    +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
107552    +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
107553    +           %end;
107554    +           %else
107555    +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
107557    +           %if &target_format ne %then %do;
107558    +              %if &target_type eq C %then %do;
107559    +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
107560    +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
107561    +              %end;
107562    +              %else
107563    +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
107564    +           %end;
107565    +           %let tarvalue =%nrbquote(%upcase(&tarvalue));
107566    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
107568    +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
107569    +           %let target_event = %nrbquote(%sysfunc(strip(&target_event)));
107570    +           %let target_nonevent = %nrbquote(%sysfunc(strip(&target_nonevent)));
107572    +           %if "&tarvalue" eq "&target_event" %then %do;
107573    +             %let totalevent = &count;
107574    +           %end;
107575    +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
107576    +              %let totalnonevent= &count;
107577    +           %end;
107578    +         %end;
107579    +         %else %do;
107580    +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
107581    +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
107583    +           %if &tarvalue eq &target_event %then %do;
107584    +             %let totalevent = &count;
107585    +           %end;
107586    +           %else %if &tarvalue eq &target_nonevent %then %do;
107587    +              %let totalnonevent= &count;
107588    +           %end;
107589    +         %end;
107590    +         %let obs = %sysfunc(fetch(&tdsid));
107591    +      %end;
107592    +   %end;
107593    +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
107595    +   proc datasets lib=work nolist;
107596    +      delete temptargetC;
107597    +   run;
107598    +   quit;
107600    +   proc means data=&FINEDETAILDATA noprint;
107601    +      var eventCount nonEventCount;
107602    +      class _variable_  _group_;
107603    +      output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
107604    +   run;
107606    +   proc sort data=summ(drop=_type_ _freq_);
107607    +     by _variable_ _group_;
107608    +   run;
107610    +   data gini(keep=_variable_ eventCount nonEventCount groupresprate)
107611    +        tempcoarse(keep=_variable_  _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
107612    +        set summ;
107613    +        *format groupresprate 6.2;
107614    +        *format groupnonresprate 6.2;
107615    +        by _variable_ ;
107616    +        if _group_=. then do;
107617    +        end;
107618    +        else do;
107619    +           respper = eventCount / &totalEvent;
107620    +           nrespper = nonEventCount / &totalNonEvent;
107622    +           if ((nonEventCount = 0) AND (eventCount = 0)) then do;
107623    +                groupresprate=0;
107624    +                groupNonresprate = 0;
107625    +                eventRate = 0;
107626    +                nonEventRate = 0;
107627    +           end;
107628    +           else do;
107629    +               groupresprate = eventCount / (eventCount + nonEventCount) ;
107630    +               groupNonRespRate = 1 - groupRespRate;
107631    +               eventRate = eventCount / &totalEvent ;
107632    +               nonEventRate = nonEventCount / &totalNonEvent ;
107633    +            end;
107635    +           output gini tempcoarse;
107637    +        end;
107638    +   run;
107639    +   proc sort data=gini;
107640    +      by _variable_ descending groupresprate;
107641    +   run;
107643    +   data gini(keep= _variable_ _gini_);
107644    +     retain between within cumresp cumnresp;
107645    +     set gini(keep=_variable_  eventCount nonEventCount);
107646    +     by _variable_;
107647    +     if first._variable_ then do;
107648    +       between  = 0;
107649    +       within   = 0;
107650    +       cumresp  = 0;
107651    +       cumnresp = 0;
107652    +     end;
107653    +     between + 2 * cumnresp * eventCount;
107654    +     within + nonEventCount * eventCount;
107655    +     cumresp + eventCount;
107656    +     cumnresp + nonEventCount;
107657    +     if last._variable_ then do;
107658    +       if ^(cumnresp=0 or cumresp=0) then do;
107659    +         _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
107660    +         output;
107661    +       end;
107662    +     end;
107663    +   run;
107665    +   data tempdisplayvar;
107666    +      set &EM_USER_VARMAPPINGS;
107667    +      rename _variable_ = display_var
107668    +      _proc_var_ = _variable_;
107669    +   keep _variable_ _proc_var_ label;
107670    +   run;
107671    +   proc sort data=tempdisplayvar; by _variable_; run;
107673    +   data  &COARSE;
107674    +     length display_Var $32 label _label_ $200 role $10 _group_ 8;
107675    +     merge tempdisplayvar tempcoarse gini ;
107676    +     by _variable_;
107677    +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
107678    +           eventRate   = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventrate_vlabel , NOQUOTE))"
107679    +           nonEventRate = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventrate_vlabel , NOQUOTE))"
107680    +           _group_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_group_vlabel , NOQUOTE))"
107681    +           role       = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel , NOQUOTE))"
107682    +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_gini_vlabel  , NOQUOTE))"
107683    +           eventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventcount_vlabel  , NOQUOTE))"
107684    +           noneventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventcount_vlabel  , NOQUOTE))"
107685    +           groupresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupresprate_vlabel  , NOQUOTE))"
107686    +           groupnonresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupnonresprate_vlabel  , NOQUOTE))"
107687    +           ;
107689    +    eventCount = round(eventCount, .001);
107690    +    nonEventCount = round(nonEventCount, .001);
107691    +    groupRespRate = round(groupRespRate, .001);
107693    +     drop _variable_ index index2 respper nrespper;
107694    +   run;
107696    +   proc datasets library=work nolist;
107697    +     delete  tempcoarse gini             ;
107699    +   run;
107700    +   quit;
107702    +%mend EM_CREATE_GROUPING;
107706    +%macro EM_GENERATE_LABELVALUES(filename, splitvals, binmappings, coarse);
107708    +         data _null_;
107709    +            FILE &filename;
107710    +            put " length _LABEL_ $200;";
107711    +            put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
107712    +         run;
107714    +         proc sort data=&SPLITVALS out=work.sortedsplitval; by display_var _split_Value_; run;
107715    +         proc sort data=&BINMAPPINGS; by display_var bin; run;
107717    +         data temp;
107718    +           merge work.sortedsplitval(in=_a) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
107719    +           by Display_Var _Split_value_;
107720    +           if upcase(_Split_value_) ne 'MISSING';
107721    +           if _a then output;
107722    +           if display_var eq '' then delete;
107723    +         run;
107725    +         data temp_missing;
107726    +           merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
107727    +           by Display_Var _Split_value_;
107728    +           if upcase(_Split_value_) eq 'MISSING';
107729    +           if _a then output;
107730    +           keep _variable_ display_var missgrp;
107731    +         run;
107733    +         proc sort data=temp out=class;
107734    +            by _variable_ _group_ LB;
107735    +         run;
107737    +         data _null_;
107739    +            file &filename MOD;
107740    +            length string $200 flag 8;
107741    +            retain string flag;
107742    +            set class end=eof;
107743    +            by _variable_  _group_;
107745    +            index = kindex(_variable_, "BIN_");
107746    +            if index gt 0 then do;
107747    +              if first._group_ then do;
107748    +                flag = 0;
107749    +                if ^first._variable_ then
107750    +                    put 'else';
107751    +                 else
107752    +                    put ' ';
107754    +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
107755    +                          !!strip(put(_GROUP_,best12.))!!' then do;';
107756    +                 put string;
107758    +                 if LB ne . then do;
107759    +                   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
107760    +                    string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
107761    +                 end;
107762    +                 else do;
107763    +                    flag = 1;
107764    +                    *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
107765    +                    string = " _LABEL_='"!!strip(DISPLAY_VAR);
107766    +                 end;
107768    +              end;
107769    +              if last._Group_ then do;
107770    +                 if UB ne . then do;
107771    +                    string = strip(string)!!'< '!!strip(UB)!!"';";
107772    +                 end;
107773    +                 else do;
107774    +                    if flag=1 then do;
107775    +                      string = strip(string)!!"';";
107776    +                     /* string = strip(string)!!'='!!strip(_split_Value_)!!"';";*/
107777    +                    end;
107778    +                    else do;
107779    +                      string = strip(string)!!"';";
107780    +                    end;
107781    +                 end;
107782    +                 put string;
107784    +                 string= " UB="!!strip(UB)!!";";
107785    +                 put string;
107786    +                 put "end;";
107789    +              end;
107790    +            end;
107791    +            else do;
107792    +              _split_value_ = tranwrd(_split_value_,"'","''");
107793    +              if first._group_ then do;
107794    +                 flag = 0;
107795    +                 if ^first._variable_ then
107796    +                    put 'else';
107797    +                 else
107798    +                    put ' ';
107799    +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
107800    +                          !!strip(put(_GROUP_,best12.))!!' then';
107801    +                 put string;
107802    +                 string = "_LABEL_='"!!strip(_split_value_);
107803    +              end;
107804    +              else do;
107805    +                 if flag ne 1 then do;
107806    +                   tempstring = strip(string)!!', '!!strip(_split_value_);
107807    +                   length = length(tempstring);
107809    +                   if length < 195 then do;
107810    +                      string = tempstring;
107811    +                   end;
107812    +                   else do;
107813    +                      string = strip(string)||",...";
107814    +                      flag=1;
107815    +                   end;
107816    +                 end;
107817    +              end;
107819    +              if last._group_ then do;
107820    +                 string = strip(string)!!"';";
107821    +                 put string;
107822    +              end;
107823    +            end;
107824    +         run;
107826    +         data &COARSE;
107827    +           set &COARSE;
107828    +          /* %inc Y; */
107829    +           %inc &filename;
107830    +         run;
107831    +         *filename Y;
107833    +         /* add missing to appropriate label - based on temp_missing data */
107834    +         data &COARSE;
107835    +           set &COARSE;
107837    +           %let dsid = %sysfunc(open(work.temp_missing));
107838    +           %if &dsid %then %do;
107839    +              %let varnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
107840    +              %let grpnum = %sysfunc(VARNUM(&dsid, MISSGRP));
107842    +              %let obs = %sysfunc(fetch(&dsid));
107843    +              %do %while(&obs=0);
107844    +                 %let var = %sysfunc(getvarc(&dsid, &varnum));
107845    +                 %let grp = %sysfunc(getvarn(&dsid, &grpnum));
107847    +                 if DISPLAY_VAR = "&var" and _GROUP_ = &grp then do;
107848    +                   if _LABEL_ eq '' then do;
107849    +                     _LABEL_ = "Missing";
107850    +                   end;
107851    +                   else do;
107852    +                     _LABEL_ = strip(_LABEL_)!!", Missing";
107853    +                   end;
107854    +                 end;
107855    +                 %let obs = %sysfunc(fetch(&dsid));
107856    +              %end;
107857    +           %end;
107858    +           %if &dsid %then %let dsid = %sysfunc(close(&dsid));
107859    +           drop ub;
107860    +         run;
107862    +         proc datasets library=work nolist;
107863    +           delete class temp temp_missing;
107864    +         run;
107865    +         quit;
107867    +%mend EM_GENERATE_LABELVALUES;
107869    +%macro calcValidationCoarse(input, output, varmappings, resultsTable);
107872    +%mend calcValidationCoarse;
107875    +%macro EM_IBN_IntTargetTrans(inttgtvar,method,newlevels=binlevs);
107876    +/* macro for transforming interval target to binary */
107878    +   %if &method = CUTMEAN %then %do;
107879    +      proc sql noprint;
107880    +         %if %EM_FREQ ne %then %do;
107881    +            select sum(&inttgtvar * %EM_FREQ) / sum(%EM_FREQ)
107882    +         %end;
107883    +         %else %do;
107884    +            select mean(&inttgtvar)
107885    +         %end;
107886    +         into :ignbincut from &em_import_data;
107887    +      quit;
107888    +   %end;
107890    +   /* create binary target */
107891    +   data &EM_USER_NEWTRAIN;
107892    +      set &EM_IMPORT_DATA;
107893    +      %if &method = CUTUSER %then %do;
107894    +           %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
107895    +      %end;
107896    +      if &inttgtvar = . then &IGNBinTarget = .;
107897    +      else do;
107898    +         if &inttgtvar > &ignbincut then &IGNBinTarget=1;
107899    +         else &IGNBinTarget=0;
107900    +      end;
107901    +   run;
107903    +   /* Check that new target is actually binary */
107904    +   proc sql noprint;
107905    +      select distinct &IGNBINTarget into :bintv1 - from &EM_USER_NEWTRAIN where &IGNBinTarget ne .;
107906    +   quit;
107907    +   %global &newlevels;
107908    +   %let &newlevels=&sqlobs;
107910    +%mend EM_IBN_IntTargetTrans;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename trtemp;
NOTE: Fileref TRTEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(EM_IBN_INTTARGETTRANS):   proc sql noprint;
MPRINT(EM_IBN_INTTARGETTRANS):   select mean(SalePrice) into :ignbincut from EMWS1.Trans_TRAIN;
NOTE: There were 218 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.VARSEL_TRAIN.
MPRINT(EM_IBN_INTTARGETTRANS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.11 seconds
      cpu time            0.11 seconds
      

MPRINT(EM_IBN_INTTARGETTRANS):   data EMWS1.BINNING_NEWTRAIN;
MPRINT(EM_IBN_INTTARGETTRANS):   set EMWS1.Trans_TRAIN;
MPRINT(EM_IBN_INTTARGETTRANS):   if SalePrice = . then BIN_SalePrice = .;
MPRINT(EM_IBN_INTTARGETTRANS):   else do;
MPRINT(EM_IBN_INTTARGETTRANS):   if SalePrice > 75017.56 then BIN_SalePrice=1;
MPRINT(EM_IBN_INTTARGETTRANS):   else BIN_SalePrice=0;
MPRINT(EM_IBN_INTTARGETTRANS):   end;
MPRINT(EM_IBN_INTTARGETTRANS):   run;

NOTE: There were 218 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.15 seconds
      cpu time            0.10 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.VARSEL_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set EMWS1.BINNING_NEWTRAIN has 193 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.21 seconds
      cpu time            0.12 seconds
      

MPRINT(EM_IBN_INTTARGETTRANS):   proc sql noprint;
MPRINT(EM_IBN_INTTARGETTRANS):   select distinct BIN_SalePrice into :bintv1 - from EMWS1.BINNING_NEWTRAIN where BIN_SalePrice ne .;
MPRINT(EM_IBN_INTTARGETTRANS):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=EMWS1 nolist;
MPRINT(TRAIN):   delete BINNING_FINEDETAILDATA;
MPRINT(TRAIN):   run;

NOTE: Deleting EMWS1.BINNING_FINEDETAILDATA (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           1.50 seconds
      cpu time            0.42 seconds
      

MPRINT(TRAIN):   data tempvarnames;
MPRINT(TRAIN):   set EMWS1.BINNING_VariableSet;
MPRINT(TRAIN):   where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
MPRINT(TRAIN):   keep NAME LEVEL LABEL;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'))) and (level not = 'UNARY');
NOTE: The data set WORK.TEMPVARNAMES has 10 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
MPRINT(TRAIN):   names NAME;
MPRINT(TRAIN):   prefix WOE_ GRP_ ;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 3 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=tempmapping;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=tempvarnames;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPVARNAMES has 10 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data tempmapping;
MPRINT(TRAIN):   merge tempmapping tempvarnames;
MPRINT(TRAIN):   by NAME;
MPRINT(TRAIN):   rename LEVEL=procLevel;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: There were 10 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 10 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_MAPPING_TABLE):  ;
MPRINT(EM_GENERATE_MAPPING_TABLE):   data EMWS1.BINNING_VARMAPPINGS(keep=_variable_ _grp_variable_ procLevel label);
MPRINT(EM_GENERATE_MAPPING_TABLE):   length _variable_ _grp_variable_ $32 procLevel $8;
MPRINT(EM_GENERATE_MAPPING_TABLE):   set tempmapping;
MPRINT(EM_GENERATE_MAPPING_TABLE):   label _variable_ = "Input Variable" _grp_variable_ = "Group Variable";
MPRINT(EM_GENERATE_MAPPING_TABLE):   _variable_ = NAME;
MPRINT(EM_GENERATE_MAPPING_TABLE):   _grp_variable_ = GRP;
MPRINT(EM_GENERATE_MAPPING_TABLE):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 10 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete tempImport tempScore;
MPRINT(TRAIN):   run;

NOTE: The file WORK.TEMPIMPORT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPSCORE (memtype=DATA) was not found, but appears on a DELETE statement.
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):   proc datasets library=EMWS1 nolist;
MPRINT(TRAIN):   delete BINNING_SPLITVALS;
MPRINT(TRAIN):   run;

NOTE: Deleting EMWS1.BINNING_SPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           1.48 seconds
      cpu time            0.34 seconds
      

MPRINT(EM_PRE_BINNING):   data tempvariableset;
MPRINT(EM_PRE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_PRE_BINNING):   where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 7 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='INTERVAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 7 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' "'!!trim(NAME)!!'"n';
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = '"'!!TRIM(NAME)!!'"n';
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=4,
      Created=Mon, Nov 19, 2018 11:48:16 PM,
      Last Modified=Mon, Nov 19, 2018 11:48:16 PM,
      Filename=C:\Users\jmmorr01\AppData\Local\Temp\SAS Temporary Files\_TD7616_COB-MBA058_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M3,Host Created=X64_8PRO

NOTE: 6 records were written to the file MACFILE.
      The minimum record length was 12.
      The maximum record length was 69.
NOTE: There were 7 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
107915    +%macro intervalvars;
107916    +"Age"n "Basement"n "Baths"n "FirePlace"n "GarageSize"n "SecondFloor"n
107917    +"TotalArea"n
107918    +%mend intervalvars;
107919    +%global num_intvars;
107920    +%let num_intvars = 7 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   proc dmdb data=EMWS1.BINNING_NEWTRAIN classout=_CLASSOUT maxlevel=5;
MPRINT(EM_PRE_BINNING):   class
MPRINT(INTERVALVARS):   "Age"n "Basement"n "Baths"n "FirePlace"n "GarageSize"n "SecondFloor"n
MPRINT(EM_PRE_BINNING):   "TotalArea"n;
MPRINT(EM_PRE_BINNING):   run;

NOTE: Records processed = 193   Memory used = 511K.
NOTE: There were 193 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set WORK._CLASSOUT has 29 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc freq data=_CLASSOUT order=DATA noprint;
MPRINT(EM_PRE_BINNING):   table NAME / OUT= _COUNT(where=(COUNT<5));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 29 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._COUNT has 3 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   set _COUNT;
MPRINT(EM_PRE_BINNING):   call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK._COUNT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc sort data=_CLASSOUT;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 29 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 29 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
MPRINT(EM_PRE_BINNING):   var NRAW;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 29 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._OUT has 7 observations and 6 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   dsid = open('_OUT');
MPRINT(EM_PRE_BINNING):   if dsid then do;
MPRINT(EM_PRE_BINNING):   call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
MPRINT(EM_PRE_BINNING):   csid = close(dsid);
MPRINT(EM_PRE_BINNING):   end;
MPRINT(EM_PRE_BINNING):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   data _INTMID;
MPRINT(EM_PRE_BINNING):   set _OUT;
MPRINT(EM_PRE_BINNING):   keep VARIABLE _MIDPOINT1--_MIDPOINT5 ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK._OUT.
NOTE: The data set WORK._INTMID has 7 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc delete data=_discretemid;
MPRINT(EM_PRE_BINNING):   run;

NOTE: Deleting WORK._DISCRETEMID (memtype=DATA).
NOTE: PROCEDURE DELETE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   label procLevel = "Level for Interactive";
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 10 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename temp catalog 'sashelp.emapps.quantile_binning.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMAPPS.QUANTILE_BINNING.SOURCE.
107922    +%macro em_apps_quantile_binning(input, vartable, numbins, binmappings, binningCode, codeMappings=, precision=0.01, dropOriginal=N, IncludeTarget=N);
107924    +  /* initialize binmappings table */
107925    +  data &BINMAPPINGS;
107926    +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
107927    +  run;
107931    +  %if &IncludeTarget=N %then %do;
107932    +   /* process only INTERVAL INPUTS */
107933    +  data tempvars;
107934    +    set &vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
107935    +  run;
107936    +  %end;
107938    +  %if &IncludeTarget=Y %then %do;
107939    +   /* process both INTERVAL INPUTS and INTERVAL TARGETS*/
107940    +  data tempvars;
107941    +    set &vartable(where=((ROLE="INPUT" AND LEVEL="INTERVAL") or (ROLE="TARGET" AND LEVEL="INTERVAL")));
107942    +  run;
107943    +  %end;
107945    +  /* retrieve the name of interval inputs to bin */
107946    +  filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
107947    +  %include tempopen;
107948    +  filename tempopen;
107950    +  %let intvars = ;
107951    +  %global num_intvars;
107952    +  %let num_intvars = 0;
107953    +  %em_varmacro(name=intvars, metadata=tempvars, key=NAME, nummacro=num_intvars);
107955    +  /* retrieve the name of frequency variable if it exists */
107956    +  %let em_bin_freq = ;
107957    +  %let choice = ROLE="FREQ";
107958    +  %let fdsid = %sysfunc(open(&vartable(where=(&choice))));
107959    +  %if &fdsid %then %do;
107960    +    %let fvarnum = %sysfunc(VARNUM(&fdsid, NAME));
107961    +    %let fobs = %sysfunc(fetch(&fdsid));
107962    +    %do %while(&fobs=0);
107963    +       %let em_bin_freq = %sysfunc(getvarc(&fdsid, &fvarnum));
107964    +       %let fobs = %sysfunc(fetch(&fdsid));
107965    +    %end;
107966    +  %end;
107967    +  %if &fdsid >0 %then %let fdsid = %sysfunc(close(&fdsid));
107969    +  /* process all inputs */
107970    +  %if &num_intvars > 0 %then %do;
107972    +    /* Computing quantile binning of interval inputs */
107973    +    %let numbin = %eval(&NUMBINS - 1);
107974    +    %let optstr=;
107975    +    %do i=1 %to &numbin;
107976    +       %let optstr = &optstr %sysevalf(&i*100/&&NUMBINS);
107977    +    %end;
107979    +    data tempInt / view = tempInt;
107980    +      set &input(keep= %intvars
107981    +      %if &em_bin_freq ne %then %do;
107982    +        &em_bin_freq
107983    +      %end;
107984    +      );
107985    +    run;
107987    +    proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=&optstr;
107988    +       var %intvars;
107989    +       %if &em_bin_freq ne %then %do;
107990    +          freq &em_bin_freq / notrunc;
107991    +       %end;
107992    +    run;
107994    +    proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
107995    +    run;
107997    +    /* generate unique BIN_xxx names for all inputs processed */
107998    +    proc dmdb data=tempvars outtable=tempmapping nameserver;
107999    +     names NAME;
108000    +     prefix BIN_ ;
108001    +    run;
108003    +    proc sort data=tempmapping(keep=NAME bin); by NAME; run;
108004    +    proc sort data=work.pctdata; by _NAME_; run;
108005    +    %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
108006    +      proc sort data=&codemappings nodupkey out=tempcodemappings(keep= codeVar variable) ; by codeVar; run;
108007    +    %end;
108009    +    data tempbins;
108010    +      length display_var $32;
108011    +      merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar))
108012    +      %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
108013    +         tempcodemappings(rename=(codeVar=_name_ variable=display_var))
108014    +      %end;
108015    +      ;
108016    +      by _NAME_;
108017    +      if _a;
108018    +      if missing(display_var) then display_var = _NAME_;
108019    +    run;
108021    +    /* generate BINMAPPINGS dataset and binningCode file*/
108022    +    data _null_;
108023    +      FILE &binningCode;
108024    +      set tempbins end=eof;
108025    +      length string $200;
108026    +      by _NAME_;
108028    +      if _n_=1 then do;
108029    +        put "&EM_CODEBAR;";
108030    +        %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
108031    +        put "* &note;";
108032    +        put "&EM_CODEBAR;";
108034    +        call execute(" data &BINMAPPINGS; ");
108035    +        call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
108036    +      end;
108038    +      %do i=1 %to %eval(&numbins-1);
108039    +       %if &i eq 1 %then %do;
108040    +         %let colname = COL&i;
108041    +         %let binvalnum = 1;
108042    +         LB = .;
108043    +         UB = round(&colname, &precision);
108044    +         bin=&binvalnum;
108046    +         call execute("name='"||strip(_NAME_)||"'; ");
108047    +         call execute("bin_name='"||strip(binVar)||"'; ");
108048    +         call execute("bin='"||strip(bin)||"';");
108049    +         call execute("LB=.;");
108050    +         call execute("UB="||UB||";");
108051    +         call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
108052    +         call execute("output;");
108054    +         string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
108056    +         put string;
108057    +         string = "else do;";
108058    +         put string;
108060    +         string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
108061    +         put string;
108064    +       %end;
108065    +       %else %do;
108066    +         %let colname = COL&i;
108067    +         %let lbnum = %sysevalf(&i-1);
108068    +         %let lbcol = COL&lbnum;
108069    +         UB = round(&colname, &precision);
108070    +         LB = round(&lbcol, &precision);
108071    +         if UB ne LB then do;
108072    +           bin=bin+1;
108074    +           call execute("name='"||strip(_NAME_)||"'; ");
108075    +           call execute("bin_name='"||strip(binVar)||"'; ");
108076    +           call execute("bin='"||strip(bin)||"';");
108077    +           call execute("LB="||LB||";");
108078    +           call execute("UB="||UB||";");
108079    +           call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
108080    +           call execute("output;");
108082    +           string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
108083    +           put string;
108085    +         end;
108086    +       %end;
108087    +      %end;
108088    +      %let binvalnum = %sysevalf(&binvalnum + 1);
108089    +      bin=bin+1;
108090    +      LB = round(&colname, &precision);
108091    +      UB = .;
108093    +      call execute("name='"||strip(_NAME_)||"'; ");
108094    +      call execute("bin_name = '"||strip(binVar)||"'; ");
108095    +      call execute("bin='"||strip(bin)||"';");
108096    +      call execute("UB=.;");
108097    +      call execute("LB="||LB||";");
108098    +      call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
108099    +      call execute("output;");
108101    +      string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
108102    +      put string;
108103    +      string="end;";
108104    +      put string;
108106    +      if eof then do;
108107    +        call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
108108    +        call execute("  if LB=UB then delete;");
108109    +        call execute("run;");
108110    +      end;
108112    +    run;
108114    +    /* drop original inputs */
108115    +    %if &dropOriginal=Y %then %do;
108116    +      data _null_;
108117    +        set work.tempvars end=eof;
108118    +        FILE &binningCode MOD;
108119    +        length string $200;
108121    +        if _n_=1 then do;
108122    +          put "drop";
108123    +        end;
108124    +        string = " "||strip(name);
108125    +        put string;
108127    +        if eof then do;
108128    +          put ";";
108129    +        end;
108130    +      run;
108131    +    %end;
108133    +    proc datasets library=work nolist;
108134    +      delete pctdata tempmapping tempbins tempInt;
108135    +    run;
108136    +    quit;
108137    +  %end;
108139    +  proc datasets library=work nolist;
108140    +    delete tempvars;
108141    +  run;
108142    +  quit;
108144    +%mend em_apps_quantile_binning;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   filename X "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data work.vartable;
MPRINT(EM_QUANTILE_BINNING):   set work._intmid;
MPRINT(EM_QUANTILE_BINNING):   level = "INTERVAL";
MPRINT(EM_QUANTILE_BINNING):   role = "INPUT";
MPRINT(EM_QUANTILE_BINNING):   rename variable=name;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK._INTMID.
NOTE: The data set WORK.VARTABLE has 7 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Variable NAME is uninitialized.
NOTE: Variable BIN_NAME is uninitialized.
NOTE: Variable LB is uninitialized.
NOTE: Variable UB is uninitialized.
NOTE: Variable BIN is uninitialized.
NOTE: Variable EM_BIN_LABEL is uninitialized.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 1 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.VARTABLE.
      WHERE (ROLE='INPUT') and (LEVEL='INTERVAL');
NOTE: The data set WORK.TEMPVARS has 7 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
NOTE: %INCLUDE (level 1) file TEMPOPEN is file SASHELP.EMUTIL.EM_VARMACRO.SOURCE.
108149    +%macro em_varMacro(name=emMacro, metadata=, where=, key=NAME, nummacro=, maxvar=-1);
108151    +   filename macFile catalog 'work.emutil.macro.source';
108152    +   %let _METAOBS = 0;
108153    +   %let _maxvar = &maxvar;
108154    +   %if "&_maxvar" eq "" %then %let maxvar = -1;
108156    +   %if (%sysfunc(exist(&metadata))<1 and %sysfunc(exist(&metadata, VIEW))<1)
108157    +                   or (&metadata eq ) %then %do;
108158    +       %put * No metadata data set defined;
108159    +       %goto doend;
108160    +   %end;
108162    +   data _null_;
108163    +      length _STRING_ $80;
108164    +      retain _STRING_ '' maxvar 0;
108165    +      set &metadata end=eof;
108166    +      file macFile;
108167    +      %if %nrbquote(&where) ne %then %do;
108168    +          %let whereClause = where (%nrbquote(&where));
108169    +          %unquote(&whereClause);
108170    +      %end;
108171    +      if _N_=1 then do;
108172    +         string = "%"!!"macro &name;";
108173    +         put string;
108174    +      end;
108175    +      maxvar +1;
108176    +      if (length(_STRING_) + length(trim(&key))+ 4 < 80) then do;
108177    +         _STRING_ = trim(_STRING_)!!' '!!trim(&key);
108178    +         if eof
108179    +            %if  %sysevalf(&_maxvar > 0) %then %do;
108180    +                or maxvar >= &maxvar
108181    +            %end;
108182    +            then do;
108183    +            put _STRING_;
108184    +            string = "%"!!"mend &name;";
108185    +            put string;
108186    +            string = strip(put(_N_, best.));
108187    +            call symput('_METAOBS', string);
108188    +            %if (&nummacro ne ) %then %do;
108189    +                put "%" "global &nummacro;";
108190    +                put "%" "let &nummacro = " string ";";
108191    +            %end;
108192    +            stop;
108193    +         end;
108194    +      end;
108195    +      else do;
108196    +         put _STRING_;
108197    +         _string_ = TRIM(&key);
108198    +         if eof
108199    +            %if  %sysevalf(&_maxvar > 0) %then %do;
108200    +              or maxvar >= &maxvar
108201    +           %end;
108202    +            then do;
108203    +            put _STRING_;
108204    +            string = "%"!!"mend &name;";
108205    +            put string;
108206    +        end;
108207    +      end;
108208    +      if eof
108209    +         %if  %sysevalf(&_maxvar > 0) %then %do;
108210    +             or maxvar >= &maxvar
108211    +         %end;
108212    +         then do;
108213    +         string = strip(put(_N_, best.));
108214    +         call symput('_METAOBS', string);
108215    +         %if (&nummacro ne ) %then %do;
108216    +             put "%" "global &nummacro;";
108217    +             put "%" "let &nummacro = " string ";";
108218    +         %end;
108219    +         stop;
108220    +      end;
108221    +   run;
108223    +   %doend:
108224    +   %if ^&_METAOBS %then %do;
108225    +       data _null_;
108226    +          file macFile;
108227    +          put "%" "macro &name;";
108228    +          put "%" "mend &name;";
108229    +          %if (&nummacro ne ) %then %do;
108230    +              put "%" "global &nummacro;";
108231    +              put "%" "let &nummacro = 0;";
108232    +          %end;
108233    +      run;
108234    +   %end;
108235    +   %inc macFile;
108236    +   filename macFile;
108237    +%mend em_varMacro;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen;
NOTE: Fileref TEMPOPEN has been deassigned.
MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvars end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Mon, Nov 19, 2018 11:48:16 PM,
      Last Modified=Mon, Nov 19, 2018 11:48:16 PM,
      Filename=C:\Users\jmmorr01\AppData\Local\Temp\SAS Temporary Files\_TD7616_COB-MBA058_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M3,Host Created=X64_8PRO

NOTE: 5 records were written to the file MACFILE.
      The minimum record length was 14.
      The maximum record length was 61.
NOTE: There were 7 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
108238    +%macro intvars;
108239    +Age Basement Baths FirePlace GarageSize SecondFloor TotalArea
108240    +%mend intvars;
108241    +%global num_intvars;
108242    +%let num_intvars = 7 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   data tempInt / view = tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN(keep
MPRINT(EM_APPS_QUANTILE_BINNING):  = Age Basement Baths FirePlace GarageSize SecondFloor TotalArea );
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: DATA STEP view saved on file WORK.TEMPINT.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=25 50 75;
MPRINT(EM_APPS_QUANTILE_BINNING):   var
MPRINT(INTVARS):   Age Basement Baths FirePlace GarageSize SecondFloor TotalArea
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: View WORK.TEMPINT.VIEW used (Total process time):
      real time           0.11 seconds
      cpu time            0.11 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: There were 193 observations read from the data set WORK.TEMPINT.
NOTE: The data set WORK.PCTDATA has 11 observations and 8 variables.
NOTE: PROCEDURE STDIZE used (Total process time):
      real time           0.13 seconds
      cpu time            0.12 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK.PCTDATA.
      WHERE _type_=:'P';
NOTE: The data set WORK.PCTDATA has 7 observations and 5 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc dmdb data=tempvars outtable=tempmapping nameserver;
MPRINT(EM_APPS_QUANTILE_BINNING):   names NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   prefix BIN_ ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPVARS.
NOTE: The data set WORK.TEMPMAPPING has 7 observations and 2 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=tempmapping(keep=NAME bin);
MPRINT(EM_APPS_QUANTILE_BINNING):   by NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 7 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.PCTDATA.
NOTE: The data set WORK.PCTDATA has 7 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempbins;
MPRINT(EM_APPS_QUANTILE_BINNING):   length display_var $32;
MPRINT(EM_APPS_QUANTILE_BINNING):   merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar)) ;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _a;
MPRINT(EM_APPS_QUANTILE_BINNING):   if missing(display_var) then display_var = _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

WARNING: Multiple lengths were specified for the BY variable _NAME_ by input data sets. This might cause unexpected results.
NOTE: There were 7 observations read from the data set WORK.PCTDATA.
NOTE: There were 7 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPBINS has 7 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X;
MPRINT(EM_APPS_QUANTILE_BINNING):   set tempbins end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "* Generating Bins for interval variables;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute(" data EMWS1.BINNING_BINMAPPINGS; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "else do;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name = '"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string="end;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if LB=UB then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("run;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      216:110   222:129   225:166   254:48    254:89    283:110   286:111   289:122   292:139   292:185   303:44    303:85    337:110   340:111   343:122   346:139   346:185   357:44    357:85    388:108   394:129   397:167   407:45    407:86    
NOTE: The file X is:
      Filename=J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=19Nov2018:23:48:16,
      Create Time=16Nov2015:19:49:42

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 43;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Age < 43';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 43;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 46;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='43 <= Age < 46';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 46;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 50;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='46 <= Age < 50';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Age';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 50;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Age >= 50';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Basement < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Basement';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Basement >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Baths < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1 <= Baths < 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_Baths';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='Baths >= 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='FirePlace < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_FirePlace';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='FirePlace >= 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='GarageSize < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_GarageSize';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='GarageSize >= 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='SecondFloor < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_SecondFloor';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='SecondFloor >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1154;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='TotalArea < 1154';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1154;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1357;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1154 <= TotalArea < 1357';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1357;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1566;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1357 <= TotalArea < 1566';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_TotalArea';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1566;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='TotalArea >= 1566';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   if NAME='' and BIN_NAME='' and BIN='' then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   if LB=UB then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;
NOTE: 43 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 63.
NOTE: There were 7 observations read from the data set WORK.TEMPBINS.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

NOTE: CALL EXECUTE generated line.
1         +  data EMWS1.BINNING_BINMAPPINGS;
2         +    length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):  32 LB UB EM_BIN_LABEL BIN200
3         + name='Age';
4         + bin_name='BIN_Age';
5         + bin='1';
6         + LB=.;
7         + UB=          43;
8         + EM_BIN_LABEL='Age < 43';
9         + output;
10        + name='Age';
11        + bin_name='BIN_Age';
12        + bin='2';
13        + LB=          43;
14        + UB=          46;
15        + EM_BIN_LABEL='43 <= Age < 46';
16        + output;
17        + name='Age';
18        + bin_name='BIN_Age';
19        + bin='3';
20        + LB=          46;
21        + UB=          50;
22        + EM_BIN_LABEL='46 <= Age < 50';
23        + output;
24        + name='Age';
25        + bin_name = 'BIN_Age';
26        + bin='4';
27        + UB=.;
28        + LB=          50;
29        + EM_BIN_LABEL='Age >= 50';
30        + output;
31        + name='Basement';
32        + bin_name='BIN_Basement';
33        + bin='1';
34        + LB=.;
35        + UB=           0;
36        + EM_BIN_LABEL='Basement < 0';
37        + output;
38        + name='Basement';
39        + bin_name = 'BIN_Basement';
40        + bin='2';
41        + UB=.;
42        + LB=           0;
43        + EM_BIN_LABEL='Basement >= 0';
44        + output;
45        + name='Baths';
46        + bin_name='BIN_Baths';
47        + bin='1';
48        + LB=.;
49        + UB=           1;
50        + EM_BIN_LABEL='Baths < 1';
51        + output;
52        + name='Baths';
53        + bin_name='BIN_Baths';
54        + bin='2';
55        + LB=           1;
56        + UB=           2;
57        + EM_BIN_LABEL='1 <= Baths < 2';
58        + output;
59        + name='Baths';
60        + bin_name = 'BIN_Baths';
61        + bin='3';
62        + UB=.;
63        + LB=           2;
64        + EM_BIN_LABEL='Baths >= 2';
65        + output;
66        + name='FirePlace';
67        + bin_name='BIN_FirePlace';
68        + bin='1';
69        + LB=.;
70        + UB=           1;
71        + EM_BIN_LABEL='FirePlace < 1';
72        + output;
73        + name='FirePlace';
74        + bin_name = 'BIN_FirePlace';
75        + bin='2';
76        + UB=.;
77        + LB=           1;
78        + EM_BIN_LABEL='FirePlace >= 1';
79        + output;
80        + name='GarageSize';
81        + bin_name='BIN_GarageSize';
82        + bin='1';
83        + LB=.;
84        + UB=           1;
85        + EM_BIN_LABEL='GarageSize < 1';
86        + output;
87        + name='GarageSize';
88        + bin_name = 'BIN_GarageSize';
89        + bin='2';
90        + UB=.;
91        + LB=           1;
92        + EM_BIN_LABEL='GarageSize >= 1';
93        + output;
94        + name='SecondFloor';
95        + bin_name='BIN_SecondFloor';
96        + bin='1';
97        + LB=.;
98        + UB=           0;
99        + EM_BIN_LABEL='SecondFloor < 0';
100       + output;
101       + name='SecondFloor';
102       + bin_name = 'BIN_SecondFloor';
103       + bin='2';
104       + UB=.;
105       + LB=           0;
106       + EM_BIN_LABEL='SecondFloor >= 0';
107       + output;
108       + name='TotalArea';
109       + bin_name='BIN_TotalArea';
110       + bin='1';
111       + LB=.;
112       + UB=        1154;
113       + EM_BIN_LABEL='TotalArea < 1154';
114       + output;
115       + name='TotalArea';
116       + bin_name='BIN_TotalArea';
117       + bin='2';
118       + LB=        1154;
119       + UB=        1357;
120       + EM_BIN_LABEL='1154 <= TotalArea < 1357';
121       + output;
122       + name='TotalArea';
123       + bin_name='BIN_TotalArea';
124       + bin='3';
125       + LB=        1357;
126       + UB=        1566;
127       + EM_BIN_LABEL='1357 <= TotalArea < 1566';
128       + output;
129       + name='TotalArea';
130       + bin_name = 'BIN_TotalArea';
131       + bin='4';
132       + UB=.;
133       + LB=        1566;
134       + EM_BIN_LABEL='TotalArea >= 1566';
135       + output;
136       +   if NAME='' and BIN_NAME='' and BIN='' then delete;
137       +   if LB=UB then delete;
138       + run;

NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 19 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.tempvars end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X MOD;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "drop";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = " "||strip(name);
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put ";";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file X is:
      Filename=J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=1342,
      Last Modified=19Nov2018:23:48:16,
      Create Time=16Nov2015:19:49:42

NOTE: 9 records were written to the file X.
      The minimum record length was 1.
      The maximum record length was 11.
NOTE: There were 7 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete pctdata tempmapping tempbins tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file WORK.TEMPINT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.PCTDATA (memtype=DATA).
NOTE: Deleting WORK.TEMPMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPBINS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.TEMPVARS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   by name lb;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 19 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.10 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   length display_var $32 grp $8;
MPRINT(EM_QUANTILE_BINNING):   display_var = name;
MPRINT(EM_QUANTILE_BINNING):   GRP = BIN + 1;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      76:92   
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      76:96   
NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 19 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedmapping nodupkey;
MPRINT(EM_QUANTILE_BINNING):   by NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: 12 observations with duplicate key values were deleted.
NOTE: The data set WORK.SORTEDMAPPING has 7 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 1 observations and 0 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   set sortedmapping;
MPRINT(EM_QUANTILE_BINNING):   GRP="1";
MPRINT(EM_QUANTILE_BINNING):   bin="Missing";
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = "Missing";
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.SORTEDMAPPING.
NOTE: The data set WORK.TEMPMISSVALUES has 7 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINDATA;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN;
NOTE: %INCLUDE (level 1) file X is file J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\BINNINGCODE.sas.
108243    +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
108244    +* Generating Bins for interval variables;
MPRINT(EM_QUANTILE_BINNING):   * Generating Bins for interval variables;
108245    +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
108246    +if Age eq . then BIN_Age= .;
MPRINT(EM_QUANTILE_BINNING):   if Age eq . then BIN_Age= .;
108247    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
108248    +if Age < 43 then BIN_Age=1;
MPRINT(EM_QUANTILE_BINNING):   if Age < 43 then BIN_Age=1;
108249    +else if Age < 46 then BIN_Age=2;
MPRINT(EM_QUANTILE_BINNING):   else if Age < 46 then BIN_Age=2;
108250    +else if Age < 50 then BIN_Age=3;
MPRINT(EM_QUANTILE_BINNING):   else if Age < 50 then BIN_Age=3;
108251    +else if Age >= 50 then BIN_Age=4;
MPRINT(EM_QUANTILE_BINNING):   else if Age >= 50 then BIN_Age=4;
108252    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
108253    +if Basement eq . then BIN_Basement= .;
MPRINT(EM_QUANTILE_BINNING):   if Basement eq . then BIN_Basement= .;
108254    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
108255    +if Basement < 0 then BIN_Basement=1;
MPRINT(EM_QUANTILE_BINNING):   if Basement < 0 then BIN_Basement=1;
108256    +else if Basement >= 0 then BIN_Basement=2;
MPRINT(EM_QUANTILE_BINNING):   else if Basement >= 0 then BIN_Basement=2;
108257    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
108258    +if Baths eq . then BIN_Baths= .;
MPRINT(EM_QUANTILE_BINNING):   if Baths eq . then BIN_Baths= .;
108259    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
108260    +if Baths < 1 then BIN_Baths=1;
MPRINT(EM_QUANTILE_BINNING):   if Baths < 1 then BIN_Baths=1;
108261    +else if Baths < 2 then BIN_Baths=2;
MPRINT(EM_QUANTILE_BINNING):   else if Baths < 2 then BIN_Baths=2;
108262    +else if Baths >= 2 then BIN_Baths=3;
MPRINT(EM_QUANTILE_BINNING):   else if Baths >= 2 then BIN_Baths=3;
108263    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
108264    +if FirePlace eq . then BIN_FirePlace= .;
MPRINT(EM_QUANTILE_BINNING):   if FirePlace eq . then BIN_FirePlace= .;
108265    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
108266    +if FirePlace < 1 then BIN_FirePlace=1;
MPRINT(EM_QUANTILE_BINNING):   if FirePlace < 1 then BIN_FirePlace=1;
108267    +else if FirePlace >= 1 then BIN_FirePlace=2;
MPRINT(EM_QUANTILE_BINNING):   else if FirePlace >= 1 then BIN_FirePlace=2;
108268    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
108269    +if GarageSize eq . then BIN_GarageSize= .;
MPRINT(EM_QUANTILE_BINNING):   if GarageSize eq . then BIN_GarageSize= .;
108270    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
108271    +if GarageSize < 1 then BIN_GarageSize=1;
MPRINT(EM_QUANTILE_BINNING):   if GarageSize < 1 then BIN_GarageSize=1;
108272    +else if GarageSize >= 1 then BIN_GarageSize=2;
MPRINT(EM_QUANTILE_BINNING):   else if GarageSize >= 1 then BIN_GarageSize=2;
108273    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
108274    +if SecondFloor eq . then BIN_SecondFloor= .;
MPRINT(EM_QUANTILE_BINNING):   if SecondFloor eq . then BIN_SecondFloor= .;
108275    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
108276    +if SecondFloor < 0 then BIN_SecondFloor=1;
MPRINT(EM_QUANTILE_BINNING):   if SecondFloor < 0 then BIN_SecondFloor=1;
108277    +else if SecondFloor >= 0 then BIN_SecondFloor=2;
MPRINT(EM_QUANTILE_BINNING):   else if SecondFloor >= 0 then BIN_SecondFloor=2;
108278    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
108279    +if TotalArea eq . then BIN_TotalArea= .;
MPRINT(EM_QUANTILE_BINNING):   if TotalArea eq . then BIN_TotalArea= .;
108280    +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
108281    +if TotalArea < 1154 then BIN_TotalArea=1;
MPRINT(EM_QUANTILE_BINNING):   if TotalArea < 1154 then BIN_TotalArea=1;
108282    +else if TotalArea < 1357 then BIN_TotalArea=2;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea < 1357 then BIN_TotalArea=2;
108283    +else if TotalArea < 1566 then BIN_TotalArea=3;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea < 1566 then BIN_TotalArea=3;
108284    +else if TotalArea >= 1566 then BIN_TotalArea=4;
MPRINT(EM_QUANTILE_BINNING):   else if TotalArea >= 1566 then BIN_TotalArea=4;
108285    +end;
MPRINT(EM_QUANTILE_BINNING):   end;
108286    +drop
108287    +Age
108288    +Basement
108289    +Baths
108290    +FirePlace
108291    +GarageSize
108292    +SecondFloor
108293    +TotalArea
108294    +;
MPRINT(EM_QUANTILE_BINNING):   drop Age Basement Baths FirePlace GarageSize SecondFloor TotalArea ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set EMWS1.BINNING_BINDATA has 193 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   length newgroup _group_ _order_ 8 _level_ $8;
MPRINT(EM_QUANTILE_BINNING):   newgroup =.;
MPRINT(EM_QUANTILE_BINNING):   _LEVEL_ = 'ORDINAL';
MPRINT(EM_QUANTILE_BINNING):   _Group_ = grp;
MPRINT(EM_QUANTILE_BINNING):   rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
MPRINT(EM_QUANTILE_BINNING):   keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      199:121   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: There were 7 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 26 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   _order_ = _N_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 26 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set WORK.TEMPSPLITVALS has 26 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals ;
MPRINT(EM_QUANTILE_BINNING):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 26 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 26 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.08 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempvariableset;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_QUANTILE_BINNING):   where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL not = 'INTERVAL') and (TYPE='C') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Mon, Nov 19, 2018 11:48:16 PM,
      Last Modified=Mon, Nov 19, 2018 11:48:17 PM,
      Filename=C:\Users\jmmorr01\AppData\Local\Temp\SAS Temporary Files\_TD7616_COB-MBA058_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M3,Host Created=X64_8PRO

NOTE: 0 records were written to the file MACFILE.
NOTE: There were 0 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   put "%" "macro classvars;";
MPRINT(EM_VARMACRO):   put "%" "mend classvars;";
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = 0;";
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Mon, Nov 19, 2018 11:48:16 PM,
      Last Modified=Mon, Nov 19, 2018 11:48:18 PM,
      Filename=C:\Users\jmmorr01\AppData\Local\Temp\SAS Temporary Files\_TD7616_COB-MBA058_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M3,Host Created=X64_8PRO

NOTE: 4 records were written to the file MACFILE.
      The minimum record length was 16.
      The maximum record length was 23.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
108295    +%macro classvars;
108296    +%mend classvars;
108297    +%global num_classvars;
108298    +%let num_classvars = 0;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 26 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 26 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by DISPLAY_VAR _Group_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 26 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 26 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.10 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete sortedmapping tempsplitvals tempmissvalues ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.SORTEDMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 3 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE LEVEL in ('BINARY', 'NOMINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 3 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc dmdb data=EMWS1.Trans_TRAIN classout=tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   class BasementType CentralAir G_ConstructionType ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Records processed = 193   Memory used = 511K.
NOTE: There were 218 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.FILTER_TRAIN.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.10 seconds
      cpu time            0.09 seconds
      
NOTE: There were 193 observations read from the data set EMWS1.VARSEL_TRAIN.
NOTE: There were 193 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set WORK.TEMPCLASSOUT has 7 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.11 seconds
      cpu time            0.11 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL='MISSING' then level='Missing';
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPCLASSOUT has 7 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=tempclassout nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by NAME descending FREQUENCY LEVEL;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPCLASSOUT has 7 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds(keep=NAME NOBS);
MPRINT(EM_CLASSVARS_GROUP):   retain NOBS;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if first.NAME then NOBS = frequency;
MPRINT(EM_CLASSVARS_GROUP):   else NOBS=NOBS+frequency;
MPRINT(EM_CLASSVARS_GROUP):   if last.name then do;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPDS has 3 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds;
MPRINT(EM_CLASSVARS_GROUP):   merge tempclassout tempds;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if ((LEVEL ne '') AND (LEVEL ne "."));
MPRINT(EM_CLASSVARS_GROUP):   PCT = 100 * (FREQUENCY/NOBS);
MPRINT(EM_CLASSVARS_GROUP):   if PCT < 0.5 then flag=1;
MPRINT(EM_CLASSVARS_GROUP):   else flag=0;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 3 observations read from the data set WORK.TEMPDS.
NOTE: The data set WORK.TEMPDS has 7 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempmissvalues;
MPRINT(EM_CLASSVARS_GROUP):   length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
MPRINT(EM_CLASSVARS_GROUP):   NAME="BasementType";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="CentralAir";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="BINARY";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="G_ConstructionType";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 3 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempsplitvals;
MPRINT(EM_CLASSVARS_GROUP):   length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   if ((level ne '') AND (level ne '.'));
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "BasementType" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "2" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "0" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "CentralAir" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "BINARY";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "1" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "0" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "G_ConstructionType" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "0" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   _VARIABLE_ = NAME;
MPRINT(EM_CLASSVARS_GROUP):   newgroup = .;
MPRINT(EM_CLASSVARS_GROUP):   rename NAME = DISPLAY_VAR LEVEL = _SPLIT_VALUE_;
MPRINT(EM_CLASSVARS_GROUP):   keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Variable _Split_value_ is uninitialized.
NOTE: There were 7 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 3 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sql;
MPRINT(EM_CLASSVARS_GROUP):   reset noprint;
MPRINT(EM_CLASSVARS_GROUP):   select count(*) into :nobs from EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 26 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 26 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.10 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = tempsplitvals nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_Value_ _group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   merge EMWS1.BINNING_SPLITVALS tempsplitvals ;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_ ;
MPRINT(EM_CLASSVARS_GROUP):   if display_var eq "" then delete;
MPRINT(EM_CLASSVARS_GROUP):   if _norm_level_ eq "" then _norm_level_ = _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 26 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: There were 10 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 36 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 36 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.12 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_CLASSVARS_GROUP):   delete tempsplitvals tempds tempclassout tempvariableset tempvars tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPDS (memtype=DATA).
NOTE: Deleting WORK.TEMPCLASSOUT (memtype=DATA).
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_CLASSVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_ORDVARS_GROUP):   by NAME;
MPRINT(EM_ORDVARS_GROUP):   where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is empty.
NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='ORDINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_ORDVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_ORDVARS_GROUP):   delete tempsplitvals varvals tempvariableset tempvars ;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: The file WORK.TEMPSPLITVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.VARVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
MPRINT(EM_ORDVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc print data=EMWS1.BINNING_VARMAPPINGS label;
MPRINT(TRAIN):   var _VARIABLE_ _GRP_VARIABLE_ ;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The PROCEDURE PRINT printed page 40.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS1.BINNING_SPLITVALS out=tempsplitvals nodupkey;
MPRINT(TRAIN):   by _VARIABLE_;
MPRINT(TRAIN):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: 26 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   length _proc_var_ $32;
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "AGE" then _proc_var_ = "BIN_Age";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "BASEMENT" then _proc_var_ = "BIN_Basement";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "BATHS" then _proc_var_ = "BIN_Baths";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "FIREPLACE" then _proc_var_ = "BIN_FirePlace";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "GARAGESIZE" then _proc_var_ = "BIN_GarageSize";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "SECONDFLOOR" then _proc_var_ = "BIN_SecondFloor";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "TOTALAREA" then _proc_var_ = "BIN_TotalArea";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "BASEMENTTYPE" then _proc_var_ = "BasementType";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "CENTRALAIR" then _proc_var_ = "CentralAir";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "G_CONSTRUCTIONTYPE" then _proc_var_ = "G_ConstructionType";
MPRINT(TRAIN):   if missing(_proc_var_) then _proc_var_=_variable_;
MPRINT(TRAIN):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 10 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.08 seconds
      cpu time            0.06 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete sortedbin tempsplitvals;
MPRINT(TRAIN):   run;

NOTE: The file WORK.SORTEDBIN (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_FINE_DETAIL):   table BIN_SalePrice / missing out=temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETB has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.06 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TEMPTARGETB (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 13 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 13 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data temptrain ;
MPRINT(EM_SUMMARIZE_TABLE):   set EMWS1.BINNING_BINDATA;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTRAIN has 193 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_PRENORMALIZECLASSVARS.SOURCE.
108299    +%macro em_PreNormalizeClassVars(incmeta=, outcmeta=);
108300    +
108301    +   data &outcmeta(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
108302    +      length INDEXVAR $32; retain _index 0;
108303    +      set &incmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
108304    +      if strip(LEVEL) eq 'INTERVAL' then delete;
108305    +      else do;
108306    +         _index+1;
108307    +         INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
108308    +      end;
108309    +   run;
108310    +%mend em_PreNormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_NORMALIZECLASSVARS.SOURCE.
108311    +%macro em_NormalizeClassVars(indata=,
108312    +                          cmeta=,
108313    +                          encodedTarget=N,
108314    +                          target=,
108315    +                          targetEvent=,
108316    +                          targetNonEvent=,
108317    +                          outdata=);
108318    + %let dsid = %sysfunc(open(&cmeta));
108319    + %let vn_name =%sysfunc(varnum(&dsid, NAME));
108320    + %let vn_indexvar =%sysfunc(varnum(&dsid, INDEXVAR));
108321    + %let vn_format =%sysfunc(varnum(&dsid, FORMAT));
108322    + %let vn_type =%sysfunc(varnum(&dsid, TYPE));
108323    +
108324    + data &outdata/view=&outdata;
108325    +      length _normedvar32 $32.;
108326    +      set &indata( rename = (
108327    +      %let k = 1;
108328    +      %do %while(^%sysfunc(fetch(&dsid)));
108329    +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
108330    +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
108331    +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
108332    +          &_name = &_indexvar
108333    +          %let k = %eval(&k+1);
108334    +      %end;
108335    +      ));
108336    +      drop  _normedvar32;
108337    +
108338    +      %let rc=%sysfunc(rewind(&dsid));
108339    +      %let k = 1;
108340    +      %do %while(^%sysfunc(fetch(&dsid)));
108341    +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
108342    +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
108343    +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
108344    +          %let _type     = %sysfunc(getvarc(&dsid, &vn_type));
108345    +          %if &_format ne %then %do;
108346    +              _normedvar32 = put(&_indexvar, &_format);
108347    +          %end;
108348    +          %else %do;
108349    +              %if &_type = N %then %do;
108350    +                  _normedvar32 = put(&_indexvar, Best12.);
108351    +              %end;
108352    +              %else %do;
108353    +                  _normedvar32 = put(&_indexvar, $32.);
108354    +              %end;
108355    +          %end;
108356    +          %DMNORMIP(_normedvar32);
108357    +          &_name = _normedvar32;
108358    +          drop &_indexvar;
108359    +          %let k = %eval(&k+1);
108360    +      %end;
108361    +      %let dsid = %sysfunc(close(&dsid));
108362    +
108363    +      %if &encodedTarget = Y %then %do;
108364    +          %let qtargetEvent = %sysfunc(quote(&targetEvent));
108365    +          %let qtargetNonEvent = %sysfunc(quote(&targetNonEvent));
108366    +          if upcase(strip(&target)) = &qtargetEvent then _EncodedTarget_ =1;
108367    +          else if upcase(strip(&target)) = &qtargetNonEvent then _EncodedTarget_ = 0;
108368    +      %end;
108369    + run;
108370    +
108371    +%mend em_NormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=tempmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPMAP has 10 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _cmeta;
MPRINT(EM_SUMMARIZE_TABLE):   merge tempvarset tempmap(in=_a rename=(_variable_=name ));
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   if ((_a) or (role="TARGET"));
MPRINT(EM_SUMMARIZE_TABLE):   if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   level = procLevel;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(name, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      79:121   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      82:105   
NOTE: There were 13 observations read from the data set WORK.TEMPVARSET.
NOTE: There were 10 observations read from the data set WORK.TEMPMAP.
NOTE: The data set WORK._CMETA has 11 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_PRENORMALIZECLASSVARS):   data _cmetatmp(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
MPRINT(EM_PRENORMALIZECLASSVARS):   length INDEXVAR $32;
MPRINT(EM_PRENORMALIZECLASSVARS):   retain _index 0;
MPRINT(EM_PRENORMALIZECLASSVARS):   set _cmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRENORMALIZECLASSVARS):   if strip(LEVEL) eq 'INTERVAL' then delete;
MPRINT(EM_PRENORMALIZECLASSVARS):   else do;
MPRINT(EM_PRENORMALIZECLASSVARS):   _index+1;
MPRINT(EM_PRENORMALIZECLASSVARS):   INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
MPRINT(EM_PRENORMALIZECLASSVARS):   end;
MPRINT(EM_PRENORMALIZECLASSVARS):   run;

NOTE: There were 10 observations read from the data set WORK._CMETA.
      WHERE ((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'));
NOTE: The data set WORK._CMETATMP has 10 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_NORMALIZECLASSVARS):   data _tmp_train/view=_tmp_train;
MPRINT(EM_NORMALIZECLASSVARS):   length _normedvar32 $32.;
MPRINT(EM_NORMALIZECLASSVARS):   set work.temptrain( rename = ( BIN_Age = _INDEXVAR1 BIN_Basement = _INDEXVAR2 BasementType = _INDEXVAR3 BIN_Baths = _INDEXVAR4 CentralAir = _INDEXVAR5 BIN_FirePlace = _INDEXVAR6 G_ConstructionType = _INDEXVAR7 
BIN_GarageSize = _INDEXVAR8 BIN_SecondFloor = _INDEXVAR9 BIN_TotalArea = _INDEXVAR10 ));
MPRINT(EM_NORMALIZECLASSVARS):   drop _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR1, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Age = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR1;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR2, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Basement = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR2;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR3, BEST.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BasementType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR3;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR4, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_Baths = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR4;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR5, BEST.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   CentralAir = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR5;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR6, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_FirePlace = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR6;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR7, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   G_ConstructionType = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR7;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR8, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_GarageSize = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR8;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR9, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_SecondFloor = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR9;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR10, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_TotalArea = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR10;
MPRINT(EM_NORMALIZECLASSVARS):   run;

NOTE: DATA STEP view saved on file WORK._TMP_TRAIN.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=sortedmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.SORTEDMAP has 10 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output CrossTabFreqs=crosstabfreq ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("proc freq data=_tmp_train order=formatted addnames;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("tables ("||_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(") * BIN_SalePrice/ missing;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   proc freq data=_tmp_train order=formatted addnames;
MPRINT(EM_SUMMARIZE_TABLE):   ) * BIN_SalePrice/ missing;
MPRINT(EM_SUMMARIZE_TABLE):   run;
MPRINT(EM_SUMMARIZE_TABLE):   ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing;
NOTE: There were 10 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         + ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   CrossTabFreqs ;
2         + ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   close
3         + proc freq data=_tmp_train order=formatted addnames;
4         + tables (BIN_Age
5         + BIN_Basement
6         + BIN_Baths
7         + BIN_FirePlace
8         + BIN_GarageSize
9         + BIN_SecondFloor
10        + BIN_TotalArea
11        + BasementType
12        + CentralAir
13        + G_ConstructionType
14        + ) * BIN_SalePrice/ missing;
15        + run;

NOTE: View WORK._TMP_TRAIN.VIEW used (Total process time):
      real time           0.16 seconds
      cpu time            0.11 seconds
      
NOTE: There were 193 observations read from the data set WORK.TEMPTRAIN.
NOTE: The data set WORK.CROSSTABFREQ has 99 observations and 21 variables.
NOTE: There were 193 observations read from the data set WORK._TMP_TRAIN.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.21 seconds
      cpu time            0.12 seconds
      

16        + ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   close
17        + ods listing;
MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("data crosstabs;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  length _variable_ _split_value_  $200 ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  set crosstabfreq(where=(_type_='11'));");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _variable_= RowVariable;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _split_value_="||_proc_var_||";");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("end;");
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabfreq(where=(_type_='11'));
MPRINT(EM_SUMMARIZE_TABLE):   _variable_= RowVariable;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Age' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Age ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Basement' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Basement ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_Baths' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_Baths ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_FirePlace' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_FirePlace ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_GarageSize' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_GarageSize ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_SecondFloor' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_SecondFloor ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_TotalArea' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_TotalArea ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BasementType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BasementType ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'CentralAir' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=CentralAir ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'G_ConstructionType' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=G_ConstructionType ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;
MPRINT(EM_SUMMARIZE_TABLE):   run;
NOTE: There were 10 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         + data crosstabs;
2         +   length _variable_ _split_value_  $200 ;
MPRINT(EM_SUMMARIZE_TABLE):  200
3         +   set crosstabfreq(where=(_type_='11'));
4         +   _variable_= RowVariable;
5         + if strip(RowVariable) = 'BIN_Age' then do;
6         +   _split_value_=BIN_Age                         ;
7         + end;
8         + if strip(RowVariable) = 'BIN_Basement' then do;
9         +   _split_value_=BIN_Basement                    ;
10        + end;
11        + if strip(RowVariable) = 'BIN_Baths' then do;
12        +   _split_value_=BIN_Baths                       ;
13        + end;
14        + if strip(RowVariable) = 'BIN_FirePlace' then do;
15        +   _split_value_=BIN_FirePlace                   ;
16        + end;
17        + if strip(RowVariable) = 'BIN_GarageSize' then do;
18        +   _split_value_=BIN_GarageSize                  ;
19        + end;
20        + if strip(RowVariable) = 'BIN_SecondFloor' then do;
21        +   _split_value_=BIN_SecondFloor                 ;
22        + end;
23        + if strip(RowVariable) = 'BIN_TotalArea' then do;
24        +   _split_value_=BIN_TotalArea                   ;
25        + end;
26        + if strip(RowVariable) = 'BasementType' then do;
27        +   _split_value_=BasementType                    ;
28        + end;
29        + if strip(RowVariable) = 'CentralAir' then do;
30        +   _split_value_=CentralAir                      ;
31        + end;
32        + if strip(RowVariable) = 'G_ConstructionType' then do;
33        +   _split_value_=G_ConstructionType              ;
34        + end;
35        + keep _variable_ _split_value_ BIN_SalePrice Frequency Percent display_var;
36        + run;

WARNING: The variable display_var in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 46 observations read from the data set WORK.CROSSTABFREQ.
      WHERE _type_='11';
NOTE: The data set WORK.CROSSTABS has 46 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 46 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 46 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length display_var $32;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 46 observations read from the data set WORK.CROSSTABS.
NOTE: There were 10 observations read from the data set WORK.SORTEDMAP.
NOTE: The data set WORK.CROSSTABS has 46 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by display_var _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 46 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 46 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 13 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 13 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
MPRINT(EM_SUMMARIZE_TABLE):   by display_var;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(_variable_, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   _temp = BIN_SalePrice;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

WARNING: Multiple lengths were specified for the BY variable display_var by input data sets. This might cause unexpected results.
NOTE: There were 46 observations read from the data set WORK.CROSSTABS.
NOTE: There were 13 observations read from the data set WORK.TEMPVARSET.
NOTE: The data set WORK.CROSSTABS has 49 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 49 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 49 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate 8 type $1 valfmt $20 ;
MPRINT(EM_SUMMARIZE_TABLE):   retain eventCount noneventCount ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   if first._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total=0;
MPRINT(EM_SUMMARIZE_TABLE):   eventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   noneventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if _temp=1 then eventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   else noneventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   if last._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total = eventCount + noneventCount;
MPRINT(EM_SUMMARIZE_TABLE):   if total ne 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = eventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = nonEventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   output;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   valfmt = format;
MPRINT(EM_SUMMARIZE_TABLE):   drop _temp Frequency percent;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      1 at 390:122   1 at 399:134   1 at 402:129   
NOTE: There were 49 observations read from the data set WORK.CROSSTABS.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 24 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):  ;
MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   length display_var $32 newgroup numsplitval 8;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   display_var = _variable_;
MPRINT(EM_FINE_DETAIL):   index = kindex(display_var, "BIN_");
MPRINT(EM_FINE_DETAIL):   if index gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 5);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   index2 = kindex(display_var, "SV_");
MPRINT(EM_FINE_DETAIL):   if index2 gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 4);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
MPRINT(EM_FINE_DETAIL):   _index_ = _N_;
MPRINT(EM_FINE_DETAIL):   newgroup = .;
MPRINT(EM_FINE_DETAIL):   drop index index2 ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Variable numsplitval is uninitialized.
NOTE: There were 24 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 24 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 24 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 24 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.12 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_FINE_DETAIL):   data tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_FINE_DETAIL):   _norm_level_ = upcase(_norm_level_);
MPRINT(EM_FINE_DETAIL):   if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
MPRINT(EM_FINE_DETAIL):   * drop _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.TMPSPLITVALS has 36 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=tmpsplitvals out=sortedsplit;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set WORK.TMPSPLITVALS.
NOTE: The data set WORK.SORTEDSPLIT has 36 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets library=work nolist;
MPRINT(EM_FINE_DETAIL):   delete tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TMPSPLITVALS (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedbin;
MPRINT(EM_FINE_DETAIL):   by BIN_NAME BIN;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.SORTEDBIN has 19 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   merge EMWS1.BINNING_FINEDETAILDATA(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   if _a then do;
MPRINT(EM_FINE_DETAIL):   binFlag = 1;
MPRINT(EM_FINE_DETAIL):   VALUE=EM_BIN_LABEL;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   else do;
MPRINT(EM_FINE_DETAIL):   binFlag = 0;
MPRINT(EM_FINE_DETAIL):   *VALUE=strip(display_var)!!"="!!strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   VALUE=strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((eventCount=.) or (nonEventCount=.)) then do;
MPRINT(EM_FINE_DETAIL):   eventCount=0;
MPRINT(EM_FINE_DETAIL):   nonEventCount=0;
MPRINT(EM_FINE_DETAIL):   total = 0;
MPRINT(EM_FINE_DETAIL):   eventRate= 0;
MPRINT(EM_FINE_DETAIL):   nonEventRate = 0;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   eventCount = round(eventCount, .001);
MPRINT(EM_FINE_DETAIL):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_FINE_DETAIL):   total= round(total, .001);
MPRINT(EM_FINE_DETAIL):   eventRate = round(eventRate, .001);
MPRINT(EM_FINE_DETAIL):   nonEventRate = round(nonEventRate, .001);
MPRINT(EM_FINE_DETAIL):   if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then numsplitval = _split_value_;
MPRINT(EM_FINE_DETAIL):   else if ((type='N') AND (valfmt ne "")) then numsplitval = _order_;
MPRINT(EM_FINE_DETAIL):   else numsplitval=.;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
MPRINT(EM_FINE_DETAIL):   if _a and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   if _c and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   drop NAME EM_BIN_LABEL valfmt;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      321:70   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 24 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: There were 36 observations read from the data set WORK.SORTEDSPLIT.
NOTE: There were 19 observations read from the data set WORK.SORTEDBIN.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 36 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Age" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Basement" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "BasementType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "Baths" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "CentralAir" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="BINARY";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "FirePlace" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "G_ConstructionType" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "GarageSize" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "SecondFloor" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "TotalArea" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then delete;
MPRINT(EM_FINE_DETAIL):   * if binFlag=1 and UB=LB then delete;
MPRINT(EM_FINE_DETAIL):   * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 36 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.18 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by DISPLAY_VAR _index_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 36 observations and 24 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete sortedsplit sortedbin ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.SORTEDSPLIT (memtype=DATA).
NOTE: Deleting WORK.SORTEDBIN (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CREATE_GROUPING):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_CREATE_GROUPING):   table BIN_SalePrice / missing out=temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 193 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETC has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets lib=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPTARGETC (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc means data=EMWS1.BINNING_FINEDETAILDATA noprint;
MPRINT(EM_CREATE_GROUPING):   var eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   class _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set WORK.SUMM has 46 observations and 6 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=summ(drop=_type_ _freq_);
MPRINT(EM_CREATE_GROUPING):   by _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 46 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.SUMM has 46 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep=_variable_ eventCount nonEventCount groupresprate) tempcoarse(keep=_variable_ _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
MPRINT(EM_CREATE_GROUPING):   set summ;
MPRINT(EM_CREATE_GROUPING):   *format groupresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   *format groupnonresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   by _variable_ ;
MPRINT(EM_CREATE_GROUPING):   if _group_=. then do;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   respper = eventCount / 98;
MPRINT(EM_CREATE_GROUPING):   nrespper = nonEventCount / 95;
MPRINT(EM_CREATE_GROUPING):   if ((nonEventCount = 0) AND (eventCount = 0)) then do;
MPRINT(EM_CREATE_GROUPING):   groupresprate=0;
MPRINT(EM_CREATE_GROUPING):   groupNonresprate = 0;
MPRINT(EM_CREATE_GROUPING):   eventRate = 0;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   groupresprate = eventCount / (eventCount + nonEventCount) ;
MPRINT(EM_CREATE_GROUPING):   groupNonRespRate = 1 - groupRespRate;
MPRINT(EM_CREATE_GROUPING):   eventRate = eventCount / 98 ;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = nonEventCount / 95 ;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   output gini tempcoarse;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 46 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.GINI has 36 observations and 4 variables.
NOTE: The data set WORK.TEMPCOARSE has 36 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=gini;
MPRINT(EM_CREATE_GROUPING):   by _variable_ descending groupresprate;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 36 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 36 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep= _variable_ _gini_);
MPRINT(EM_CREATE_GROUPING):   retain between within cumresp cumnresp;
MPRINT(EM_CREATE_GROUPING):   set gini(keep=_variable_ eventCount nonEventCount);
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   if first._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   between = 0;
MPRINT(EM_CREATE_GROUPING):   within = 0;
MPRINT(EM_CREATE_GROUPING):   cumresp = 0;
MPRINT(EM_CREATE_GROUPING):   cumnresp = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   between + 2 * cumnresp * eventCount;
MPRINT(EM_CREATE_GROUPING):   within + nonEventCount * eventCount;
MPRINT(EM_CREATE_GROUPING):   cumresp + eventCount;
MPRINT(EM_CREATE_GROUPING):   cumnresp + nonEventCount;
MPRINT(EM_CREATE_GROUPING):   if last._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   if ^(cumnresp=0 or cumresp=0) then do;
MPRINT(EM_CREATE_GROUPING):   _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
MPRINT(EM_CREATE_GROUPING):   output;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 36 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 10 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(EM_CREATE_GROUPING):   rename _variable_ = display_var _proc_var_ = _variable_;
MPRINT(EM_CREATE_GROUPING):   keep _variable_ _proc_var_ label;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 10 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPDISPLAYVAR has 10 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: The data set WORK.TEMPDISPLAYVAR has 10 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data EMWS1.BINNING_COARSE;
MPRINT(EM_CREATE_GROUPING):   length display_Var $32 label _label_ $200 role $10 _group_ 8;
MPRINT(EM_CREATE_GROUPING):   merge tempdisplayvar tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   label display_var = "Variable" eventRate = "Event Rate" nonEventRate = "Non-Event Rate" _group_ = "Group" role = "Role" _gini_ = "Gini Coefficient" eventcount = "Event Count" noneventcount = "Non-Event Count" groupresprate = 
"Group Event Rate" groupnonresprate = "Group Non-Event Rate" ;
MPRINT(EM_CREATE_GROUPING):   eventCount = round(eventCount, .001);
MPRINT(EM_CREATE_GROUPING):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_CREATE_GROUPING):   groupRespRate = round(groupRespRate, .001);
MPRINT(EM_CREATE_GROUPING):   drop _variable_ index index2 respper nrespper;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Variable _label_ is uninitialized.
NOTE: Variable role is uninitialized.
WARNING: Multiple lengths were specified for the BY variable _variable_ by input data sets. This might cause unexpected results.
WARNING: The variable index in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable index2 in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 10 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: There were 36 observations read from the data set WORK.TEMPCOARSE.
NOTE: There were 10 observations read from the data set WORK.GINI.
NOTE: The data set EMWS1.BINNING_COARSE has 36 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets library=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPCOARSE (memtype=DATA).
NOTE: Deleting WORK.GINI (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y "J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas";
MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   FILE Y;
MPRINT(EM_GENERATE_LABELVALUES):   put " length _LABEL_ $200;";
MPRINT(EM_GENERATE_LABELVALUES):   put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: The file Y is:
      Filename=J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=19Nov2018:23:48:20,
      Create Time=16Nov2015:19:49:42

NOTE: 2 records were written to the file Y.
      The minimum record length was 21.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_SPLITVALS out=work.sortedsplitval;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var _split_Value_;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.SORTEDSPLITVAL has 36 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var bin;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 19 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.10 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) ne 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   if display_var eq '' then delete;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP has 26 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) eq 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   keep _variable_ display_var missgrp;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 19 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP_MISSING has 10 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=temp out=class;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_ LB;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 26 observations read from the data set WORK.TEMP.
NOTE: The data set WORK.CLASS has 26 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   file Y MOD;
MPRINT(EM_GENERATE_LABELVALUES):   length string $200 flag 8;
MPRINT(EM_GENERATE_LABELVALUES):   retain string flag;
MPRINT(EM_GENERATE_LABELVALUES):   set class end=eof;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_;
MPRINT(EM_GENERATE_LABELVALUES):   index = kindex(_variable_, "BIN_");
MPRINT(EM_GENERATE_LABELVALUES):   if index gt 0 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then do;';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   if LB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 1;
MPRINT(EM_GENERATE_LABELVALUES):   *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._Group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   if UB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!'< '!!strip(UB)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag=1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string= " UB="!!strip(UB)!!";";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   put "end;";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _split_value_ = tranwrd(_split_value_,"'","''");
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string = "_LABEL_='"!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag ne 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   tempstring = strip(string)!!', '!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   length = length(tempstring);
MPRINT(EM_GENERATE_LABELVALUES):   if length < 195 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = tempstring;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)||",...";
MPRINT(EM_GENERATE_LABELVALUES):   flag=1;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      171:84    206:151   246:25    
NOTE: The file Y is:
      Filename=J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=108,
      Last Modified=19Nov2018:23:48:20,
      Create Time=16Nov2015:19:49:42

NOTE: 116 records were written to the file Y.
      The minimum record length was 1.
      The maximum record length was 56.
NOTE: There were 26 observations read from the data set WORK.CLASS.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
NOTE: %INCLUDE (level 1) file Y is file J:\CIS-445-Project-4-master\CIS-445-Project-4-master\Project_4\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas.
108372    + length _LABEL_ $200;
MPRINT(EM_GENERATE_LABELVALUES):   length _LABEL_ $200;
108373    + label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";
MPRINT(EM_GENERATE_LABELVALUES):   label _LABEL_= "Group Values";
108374    +
108375    +if DISPLAY_VAR='Age' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Age' and _GROUP_ = 2 then do;
108376    +_LABEL_='Age< 43';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Age< 43';
108377    +UB=43;
MPRINT(EM_GENERATE_LABELVALUES):   UB=43;
108378    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108379    +else
108380    +if DISPLAY_VAR='Age' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 3 then do;
108381    +_LABEL_='43<= Age< 46';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='43<= Age< 46';
108382    +UB=46;
MPRINT(EM_GENERATE_LABELVALUES):   UB=46;
108383    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108384    +else
108385    +if DISPLAY_VAR='Age' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 4 then do;
108386    +_LABEL_='46<= Age< 50';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='46<= Age< 50';
108387    +UB=50;
MPRINT(EM_GENERATE_LABELVALUES):   UB=50;
108388    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108389    +else
108390    +if DISPLAY_VAR='Age' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Age' and _GROUP_ = 5 then do;
108391    +_LABEL_='50<= Age';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='50<= Age';
108392    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
108393    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108394    +
108395    +if DISPLAY_VAR='Basement' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Basement' and _GROUP_ = 2 then do;
108396    +_LABEL_='Basement< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Basement< 0';
108397    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
108398    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108399    +else
108400    +if DISPLAY_VAR='Basement' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Basement' and _GROUP_ = 3 then do;
108401    +_LABEL_='0<= Basement';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= Basement';
108402    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
108403    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108404    +
108405    +if DISPLAY_VAR='Baths' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='Baths' and _GROUP_ = 2 then do;
108406    +_LABEL_='Baths< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='Baths< 1';
108407    +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
108408    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108409    +else
108410    +if DISPLAY_VAR='Baths' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Baths' and _GROUP_ = 3 then do;
108411    +_LABEL_='1<= Baths< 2';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= Baths< 2';
108412    +UB=2;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2;
108413    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108414    +else
108415    +if DISPLAY_VAR='Baths' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='Baths' and _GROUP_ = 4 then do;
108416    +_LABEL_='2<= Baths';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2<= Baths';
108417    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
108418    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108419    +
108420    +if DISPLAY_VAR='FirePlace' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='FirePlace' and _GROUP_ = 2 then do;
108421    +_LABEL_='FirePlace< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='FirePlace< 1';
108422    +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
108423    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108424    +else
108425    +if DISPLAY_VAR='FirePlace' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='FirePlace' and _GROUP_ = 3 then do;
108426    +_LABEL_='1<= FirePlace';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= FirePlace';
108427    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
108428    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108429    +
108430    +if DISPLAY_VAR='GarageSize' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='GarageSize' and _GROUP_ = 2 then do;
108431    +_LABEL_='GarageSize< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='GarageSize< 1';
108432    +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
108433    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108434    +else
108435    +if DISPLAY_VAR='GarageSize' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='GarageSize' and _GROUP_ = 3 then do;
108436    +_LABEL_='1<= GarageSize';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= GarageSize';
108437    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
108438    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108439    +
108440    +if DISPLAY_VAR='SecondFloor' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='SecondFloor' and _GROUP_ = 2 then do;
108441    +_LABEL_='SecondFloor< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='SecondFloor< 0';
108442    +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
108443    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108444    +else
108445    +if DISPLAY_VAR='SecondFloor' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='SecondFloor' and _GROUP_ = 3 then do;
108446    +_LABEL_='0<= SecondFloor';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= SecondFloor';
108447    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
108448    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108449    +
108450    +if DISPLAY_VAR='TotalArea' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='TotalArea' and _GROUP_ = 2 then do;
108451    +_LABEL_='TotalArea< 1154';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='TotalArea< 1154';
108452    +UB=1154;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1154;
108453    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108454    +else
108455    +if DISPLAY_VAR='TotalArea' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 3 then do;
108456    +_LABEL_='1154<= TotalArea< 1357';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1154<= TotalArea< 1357';
108457    +UB=1357;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1357;
108458    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108459    +else
108460    +if DISPLAY_VAR='TotalArea' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 4 then do;
108461    +_LABEL_='1357<= TotalArea< 1566';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1357<= TotalArea< 1566';
108462    +UB=1566;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1566;
108463    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108464    +else
108465    +if DISPLAY_VAR='TotalArea' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='TotalArea' and _GROUP_ = 5 then do;
108466    +_LABEL_='1566<= TotalArea';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1566<= TotalArea';
108467    +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
108468    +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
108469    +
108470    +if DISPLAY_VAR='BasementType' and _GROUP_ = 2 then
108471    +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='BasementType' and _GROUP_ = 2 then _LABEL_='2';
108472    +else
108473    +if DISPLAY_VAR='BasementType' and _GROUP_ = 3 then
108474    +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='BasementType' and _GROUP_ = 3 then _LABEL_='1';
108475    +else
108476    +if DISPLAY_VAR='BasementType' and _GROUP_ = 4 then
108477    +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='BasementType' and _GROUP_ = 4 then _LABEL_='0';
108478    +
108479    +if DISPLAY_VAR='CentralAir' and _GROUP_ = 2 then
108480    +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='CentralAir' and _GROUP_ = 2 then _LABEL_='1';
108481    +else
108482    +if DISPLAY_VAR='CentralAir' and _GROUP_ = 3 then
108483    +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CentralAir' and _GROUP_ = 3 then _LABEL_='0';
108484    +
108485    +if DISPLAY_VAR='G_ConstructionType' and _GROUP_ = 2 then
108486    +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='G_ConstructionType' and _GROUP_ = 2 then _LABEL_='0';
108487    +else
108488    +if DISPLAY_VAR='G_ConstructionType' and _GROUP_ = 3 then
108489    +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='G_ConstructionType' and _GROUP_ = 3 then _LABEL_='1';
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 36 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   *filename Y;
MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Age" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Basement" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "BasementType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "Baths" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "CentralAir" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "FirePlace" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "G_ConstructionType" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "GarageSize" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "SecondFloor" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "TotalArea" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   drop ub;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 36 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 36 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc datasets library=work nolist;
MPRINT(EM_GENERATE_LABELVALUES):   delete class temp temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Deleting WORK.CLASS (memtype=DATA).
NOTE: Deleting WORK.TEMP (memtype=DATA).
NOTE: Deleting WORK.TEMP_MISSING (memtype=DATA).
MPRINT(EM_GENERATE_LABELVALUES):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y;
NOTE: Fileref Y has been deassigned.
MPRINT(EM_MODEL):   data WORK.EM_USER_MODEL;
MPRINT(EM_MODEL):   length DATA $65 TARGET $32 PREDICTED ASSESS DECSCORECODE FITSTATISTICS CLASSIFICATION RESIDUALS $1;
MPRINT(EM_MODEL):   data = "";
MPRINT(EM_MODEL):   target = "BIN_SalePrice";
MPRINT(EM_MODEL):   predicted = "Y";
MPRINT(EM_MODEL):   assess = "N";
MPRINT(EM_MODEL):   decscorecode = "N";
MPRINT(EM_MODEL):   fitstatistics = "N";
MPRINT(EM_MODEL):   classification = "N";
MPRINT(EM_MODEL):   residuals = "N";
MPRINT(EM_MODEL):   run;

NOTE: The data set WORK.EM_USER_MODEL has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "COARSE";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "EVENTRATESTAT";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "MODEL";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.03489559843898;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;

NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
108490     *------------------------------------------------------------*;
108491     * End TRAIN: BINNING;
108492     *------------------------------------------------------------*;
108493     

108494     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
108495     * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
108496     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
108497     ;
MPRINT(EM_DIAGRAM):   ;
108498     ;
MPRINT(EM_DIAGRAM):   ;
108499     ;
MPRINT(EM_DIAGRAM):   ;
108500     ;
MPRINT(EM_DIAGRAM):   ;
108501     quit;
MPRINT(EM_DIAGRAM):   quit;
108502     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
108503     * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
108504     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
108505     /*; *"; *'; */
108506     ;
MPRINT(EM_DIAGRAM):   ;
108507     run;
MPRINT(EM_DIAGRAM):   run;
108508     quit;
MPRINT(EM_DIAGRAM):   quit;
108509     /* Reset EM Options */
108510     options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
108511     options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
108512     goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
108513     proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
108514     by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
108515     run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
